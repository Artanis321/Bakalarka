% !TeX spellcheck = sk_SK
\section{Malvér}
\noindent

\noindent Je to softvér, ktorého cie¾om je poškodi, zablokova, zmocni sa alebo odcudzi citlivé informácie uloené v poèítaèi. Cie¾om malvéru je získa informácie pre útoèníka a následné zneuitie tıchto informácií na rôzne druhy nelegálnej èinnosti za úèelom danej obeti uškodi alebo sa na nej finanène obohati. Malvér sa kedysi èlenil na rôzne kategórie ako napr. vírusy, \textit{backdoor}, \textit{spyware}, \textit{ramsomware} a pod.\cite{malvare} V súèasnosti u toto delenie nie je ve¾mi aktuálne, pretoe malvér v dnešnej dobe je u viacmenej kombináciou tıchto kategórií a vyuíva rôzne komponenty z jednotlivıch druhov škodlivého kódu. V nasledujúcej kapitole sa podrobnejšie zaoberáme rôznymi spôsobmi ukrıvania èinnosti a prítomnosti malvéru, ktoré môu by v súèasnosti vyuívané.
\vspace{20px}
\subsection{Techniky ukrıvania èinnosti}
\noindent 
Malvér vo všeobecnosti patrí ku škodlivému kódu. Preto je nutné jeho beiace procesy utaji. Ak chce by malvér úspešnı v získavaní údajov alebo finanènıch prostriedkov, musí by jeho beh ukrytı pred potenciálnym antivírusom, prípadne forenznım ininierom ktorı je schopnı ho odhali. Za tımto úèelom sa vyuívajú rôzne techniky na ukrytie malvéru buï v pamäti poèítaèa, rôznych shell skriptoch alebo dynamickıch kniniciach, aby boli èo najmenej detegovate¾né. \cite{malicious}

\begin{itemize}
	\item 
\textbf{DLL Injection / Reflective DLL Injection}
\noindent \\ \textit{DLL Injection} je technika, pri ktorej malvér zapíše cestu ku škodlivému DLL súboru do virtuálneho adresného priestoru legitímneho procesu a následne zabezpeèí aby danı proces túto dynamickú kninicu naèítal. Postup je nasledovnı: 

\begin{itemize}
	\item Škodlivı kód získa prístup ku legitímnemu procesu.
	\item V rámci legitímneho procesu alokuje priestor dostatoène ve¾kı na zapísanie cesty ku škodlivému DLL súboru.
	\item Malvér zapíše cestu ku škodlivému DLL súboru do virtuálneho adresného priestoru legitímneho procesu.
	\item Malvér na záver spustí vlákno v rámci legitímneho procesu, ktorého cie¾om je naèíta a spusti DLL súbor.
\end{itemize}

Hlavnım cie¾om \textit{DLL Injection} je škodlivı kód ukry do legitímneho procesu, kde je malvér ukrytı pred antivírovım softvérom, odkia¾ môe by následne spustenı \cite{endgame}.

\item 
\textbf{Proces Hollowing}
\noindent \\ Vyuíva podobné princípy ukrıvania škodlivého softvéru ako \textit{DLL Injection}. Cie¾om je ukry škodlivı kód do existujúce procesu, z ktorého sa následne bude vykonáva\cite{endgame}. Princíp je podobnı ako pri technike \textit{DLL Injection}:
\begin{itemize}
	\item Malvér spustí novı pozastavenı legitímny proces, do ktorého sa plánuje ukry.
	\item Škodlivı kód odmapuje pamä legitímneho procesu.
	\item Do virtuálneho adresného priestoru legitímneho procesu nakopíruje svoj škodlivı kód.
	\item Po dokonèení kopírovania nastaví novı vstupnı bod procesu a obnoví pozastavenı proces.
\end{itemize}

Ako môeme vidie, hlavnı rozdiel spoèíva najmä v odmapovaní existujúceho kódu. V prípade \textit{Process Hollowing} techniky bude v rámci neškodného procesu bea vıhradne iba škodlivı kód, na rozdiel od \textit{DLL injection}, kde v rámci jedného procesu sa nachádza škodlivı kód spolu s pôvodnım. Vısledkom môe by napr. spustenı benı proces \textit{svchost.exe}, ktorı ale v skutoènosti vykonáva škodlivú aktivitu.
\item 
\textbf{Thread Execution Hijacking }
\noindent \\
Pri tejto technike existujú urèité podobnosti s metódou \textit{Process Hollowing} a \textit{DLL injection} \cite{endgame}. Hlavnı princíp spoèíva v získaní prístupu u k existujúcemu vláknu legitímneho procesu, do ktorého chceme vloi škodlivı kód. Po získaní prístupu k vláknu, malvér dané vlákno pozastaví. Samotné injektovanie môe uskutoèni podobne ako pri \textit{DLL injection}, zapísaním cesty k DLL súboru a následnom naèítaní. Nevıhodou takéhoto spustenia pozastaveného programu je, e môe spôsobi pád systému v rámci systémového volania. Vıhodou ostáva, e technika nepotrebuje vytvori nové vlákno alebo proces a pouije u existujúce.

\item 
\textbf{Portable Executable Injection}
\noindent \\ 
Vıhodou tohoto spôsobu ukrytia malvéru je vyuitie nakopírovania celého PE súboru do existujúceho procesu \cite{endgame}. Ako vıhodu môeme taktie povavaova, e malvér nepotrebuje uloi iadne súbory na disk ale len priamo prekopíruje dáta PE súboru do legitímneho procesu. Hlavnou nevıhodou je, e sa zmení bázová adresa procesu a z toho dôvodu je nutné prepoèíta nové adresy v legitímnom procese tak, aby bolo zabezpeèené korektné správanie novo vloeného PE súboru.

\item 
\textbf{Hook injection}
\noindent \\
Hookovanie je všeobecne technika pouívaná na zachytávanie API volaní. \textit{Hook injection} vyuíva túto techniku na naèítanie škodlivého DLL, pri zachytení urèitej udalosti v konkrétnom vlákne \cite{endgame}. Pomocou prislušného API volania vieme nainštalova hook na špecifickú udalos v systéme (napr. stlaèenie klávesy), pre konkrétne vlákno v systéme. Taktie vieme špecifikova smerník na funkciu, ktorá sa má zavola ak daná udalos nastane. V tejto funkcii následne vieme urèi e sa má naèíta napr. škodlivé DLL. Môeme si všimnú e väšèina techník sa samotné naèítanie kódu vyuíva metódu naèítania škodlivého DLL do regulérneho procesu a hlavné rozdiely spoèívajú najmä v riešení ako donúni cudzí proces túto funkcionalitu vyvola.

\item 
\textbf{APC Injection}
\noindent \\
Škodlivı softvér môe vyuíva vıhody tzv. \textit{Asynchronous Procedure Calls} (APC), aby prinútil iné vlákno spusti svoj vlastnı kód \cite{endgame}. Túto funkcionalitu vie dosiahnú tak, e vloí dané vlákno do APC fronty. Kadé vlákno má vlastnú APC frontu, z ktorej vykonáva volania ak sa nachádza v pozastavenom stave a èaká na konkrétne udalosti. Podobne ako v predchádzajúcich prípadoch môe malvér do APC fronty vloi smerník na funkciu, v ktorej sa naèíta škodlivé DLL. Malvér zvyèajne h¾adá ¾ubovo¾né vlákno ktoré sa nachádza v špeciálnom stave, pri ktorom vykonáva postupne poloky v APC fronte. Takıchto vláken je väèšinou v systéme ve¾a.

\item 
\textbf{Extra windows memory injection}
\noindent \\
Tento spôsob schovávania softvéru sa spolieha na monos špecifikova dodatoènú pamä pri registrácii aplikaènıch okien v systéme. Pri registrácii nového okna aplikácie, softvér špecifikuje ïalšie bajty pamäte, ktoré rozšíria ve¾kos alokovanej pamäte pre spustenú aplikáciu \cite{endgame}, nazıvané aj \textit{Extra Windows Memory}(EWM). V tejto èasti ale nevzniká dostatok miesta na uloenie dát. Aby sa toto obmedzenie obišlo, škodlivı softvér zapíše kód do zdie¾anej pamäte a do EWM vloí ukazovate¾ na danú èast. Do tejto rozšírenej èasti zie¾anej pamäte ïalej softvér zapíše smerník na funkciu, ktorá obsahuje kód na naèítanie malvéru. Malvér môe nakoniec vyvola spustenie tohoto kódu pomocou konkrétnych Windows API volaní.
\end{itemize}
\vspace{20px}
\subsection{Súèasnı malvér}
\noindent \\
Táto kapitola obsahuje opis jednotlivıch vzoriek škodlivého kódu z roku 2019, ktoré boli detegované spoloènosami ako Avast a McAfee. Tieto vzorky sú najèastejšie vyuívané v oblasti Európy. Kapitola obsahuje bliší opis jednotlivıch vzoriek, ich vyuitie, pouité spôsoby útokov a ukrytie malvéru v systéme.

\begin{itemize}
\item
\textbf{Sodinokibi}
\noindent \\
Tento malvér bol detekovanı v období okolo apríla 2019. Patrí do rodiny ransomvéru, ktorıch cie¾om je zašifrova dáta v zariadení a následne za dešifrovanie pıta peniaze \cite{sinobiki} (väèšinou v podobe kryptomeny). Názov bol objavenı v heši, ktorı obsahoval názov \textit{Sodinokibi.exe}. Vírus sa šíri sám zmeuívaním zranite¾nosti v serveroch, ktoré pouívajú \textit{Oracle WebLogic}. Kód je navrhnutı tak, aby rıchlo vykonával šifrovanie špecifickıch súborov, definovanıch v konfigurácii ransomvéru. Prvou akciou škodlivého kódu je naèíta všetky externé funkcie potrebné poèas behu programu. Technika vyuívaná na ukrytie malvéru je \textit{Portable Executable Injection}. Analıza spoloènosti McAfee ukazuje podobnos s inım starším malvérom GandCrab.

\item
\textbf{Emotet}
\noindent \\
Emotet je malvér, ktorı sa primárne šíri pomocou rôznych spam emailov \cite{emotet2}. Na infikovanie zariadenia pouíva rôzne skripty, makrá v dokumetoch alebo linky. Emotet sa teda spolieha najmä na techniky sociálneho ininierstva. Prezentuje sa ako hodnovernı zástupca napr. banky, rôznych internetovıch obchodov, a pod. Emotet sa prvıkrát objavil v roku 2014 kedy vyuíval na infikovanie rôzne JavaScript súbory \cite{emotet}. V roku 2019 sa tento vírus objavil znova tentokrát u v pokroèilejšej verzii.  V novej verzii je Emotet u polymorfnım škodlivım kódom, èo mu umoòuje vyhnú sa klasickej detekcii. Emotet môe navyše generova falošné funkcionalitu, ak je spustenı vo virtuálnom prostredí èo zhoršuje jeho detekciu systéme.

\item
\textbf{ZeuS}
\noindent \\
Prvıkrát odhalenı v roku 2007 sa Zeus Trojan, ktorı sa èasto nazıva Zbot, stal jednım z najúspešnejších botnetov na svete a postihol milióny poèítaèov \cite{zeus2}. Taktie bolo vytvorernıch mnostvo variantov, ktoré boli zaloené na tomto malvéri. Po èase sa znovu objavil v pozmenenej podobe so zameraním na odchytávanie bankovıch operácii (odchytávanie prihlasovacích údajov do internet bankingu). Dosahuje to prostredníctvom monitorovania webovıch stránok a zaznamenávania klávesov. Keï malvér zistí, e sa pouívate¾ nachádza na webovej stránke banky, zaène zaznamenáva stlaèenia klávesov pouité na prihlásenie. Infekcia prebieha pomocou spamov. Keï uívate¾ klikne na odkaz v správe alebo stiahne obsah súboru, spolu s ním stiahne a spustí aj makro, ktoré po nainštalovaní umoòuje sledovanie zariadenia. 

\item
\textbf{Dridex}
\noindent \\
Dridex je známy trójsky kôò, ktorı sa špecializuje na kráde kreditnıch údajov v online bankovníctve. Tento typ škodlivého kódu sa objavil v roku 2014 a stále sa postupne vyvíja. Novı variant Dridex je schoplnı vyhnú sa detekcii tradiènımi antivírusovımi produktami. Tento malvér je v súèastnosti schopnı detekova pribline 25 a 30 percent aktuálnych antivírusovıch softvérov. \cite{dridex}

\item
\textbf{Mirai}
\noindent \\
\textit{Mirai} je samošírite¾nı typ škodlivého súboru na vytvorenie botnetu. Zdrojovı kód pre \textit{Mirai} bol autormi verejne sprístupnenı po úspešnom a dobre propagovanom útoku na webovú stránku Krebbs. Kód botnetu Mirai infikuje zariadania pripojené k internetu, ktoré vyuívajú telnet protokol (sieovı komunikaènı protokol zaloenı na TCP) na nájdenie tıch, ktoré stále pouívajú svoje predvolené uivate¾ské meno a heslo. Úèinnos málvéru \textit{Mirai} je spôsobená jeho schopnosou infikova desiatky tisíc tıchto nezabezpeèenıch zariadení a koordinova ich tak, aby zaèali útok DDoS proti vybranej obeti. \cite{mirai}

Mirai má dve hlavné zloky, samotnı vírus a C\&C server, ktorı ovláda kompromitované zariadenia (BOT) a posiela im pokyny na spustenie jedného z útokov proti jednej alebo viacerım obetiam. Proces skenera prebieha nepretrite na kadom infikovanom zariadení pomocou protokolu telnet (na porte TCP 23 alebo 2323)

C\&C predstavuje jednoduché rozhranie príkazového riadku, ktoré umoòuje útoèníkovi urèi algoritmus, IP adresu obete a trvanie útoku. C\&C tie èaká na to, aby jej existujúce BOT-y vrátili novoobjavené adresy zariadení, ktoré pouíva na ïalšie rozširovanie botnetu. Algoritmy sú konfigurovate¾né z C\&C, ale v predvolenom nastavení má \textit{Mirai} tendenciu náhodne rozde¾ova rôzne polia (ako sú èísla portov, poradové èísla, identifikátory atï.).

\item
\textbf{Osiris}
\noindent \\
Osiris je odvodenı od malvéru Kronos, ktorı sa zameriaval na bankovnívctvo. Podobne ako Kronos, je Osiris modernejšou verziou bankového trójskeho koòa \cite{osiris}. Táto verzia malvéru vyuíva na skrıvanie metódu \textit{process hollowing}. Umoòuje mu vydáva sa za legitímne procesy. Malvér sa šíri vydávaním sa za legitímny spustite¾nı súbor (útoky zaznamenné s malvérom Osiris boli dokumenty Microsoft Word). Vydávanie sa za inı oficiálny softvér znaène sauje identifikáciu malvéru a obmedzuje monosti na zastavenie útoku \cite{osiris2}. Malvér v dokumetoch Word obsahoval aj makrá, ktoré po spustení stiahli další škodlivı malvér, ktorı umouje zahåti zariadenia alebo sai detekcu

\item
\textbf{Loki}
\noindent \\
Loki je ïalšou variáciou staršieho malvéru Kronos. Rovnako ako Osiris, aj Loki vyuíva na svoje ukrytie metódu \textit{process hollowing}. Loki sa zameriava na krádee osobnıch údajov ako napr. prihlasovacie údaje a heslá. Od augusta 2018 a do súèasnosti sa Loki zameriava na firemné poštové schránky prostredníctvom phishingovıch a spamovıch e-mailov. Phishingové e-maily zahàòajú prílohu súboru s príponou .iso, ktorá sahuje a spúša škodlivı softvér.
\end{itemize}

Celkovı preh¾ad pouítıch techník v súèasnım vzorkách škodlivého kódu môeme vidie v tabu¾ke è.\ref{modulyVlastnosti}.
\begin{table}[!htbp]
	\begin{center}
		\begin{tabular}{p{4cm}|c|c|c|c|c|c|c|c}
			& \multicolumn{7}{c}%
			{\textbf{Technika ukrıvania}}\\ \hline
			\textbf{Názov malvéru} &\begin{sideways} Sodinokibi \end{sideways} &\begin{sideways} Emotet \end{sideways} &\begin{sideways} ZeuS \end{sideways} & \begin{sideways} Dridex \end{sideways} & \begin{sideways} Mirai \end{sideways} & \begin{sideways} Osiris \end{sideways}  & \begin{sideways} Loki \end{sideways} \\ \hline
			DLL Injection & & X & X & & X & &	\\ \hline
			Process hollowing & & & & & & X & X	\\ \hline
			Thread Execution Hijacking & & & & & & & 	\\ \hline
			Portable Executable Injection  & X & & & X & & &	\\ \hline
			Hook injection  & & & & & & &	\\ \hline
			APC Injection  & & & & & & &	\\ \hline
			Extra windows memory injection & & & & & & &	\\ \hline
		\end{tabular}
	\caption{Techniky ukrıvania èinnosti vyuívané súèasnım malvérom.}
\label{modulyVlastnosti}
\end{center}
\end{table}

\section{Process hollowing}
\noindent

Zvolenı spôsob ukrytia malvéru, ktorım sme sa v tejto práci zaoberali je \textit{process hollowing}. Nasledujúca kapitola sa venuje spôsobu akım sa malvér môe ukry pomocou spomínanej techniky. Taktie obsahuje potenciálne API funkcie pomocou ktorıch môe by technika \textit{process hollowing} implementovaná.

\begin{figure}[!htbp]
	\centering
	\includegraphics[width=12cm]{img/Diagram.jpg}
	\caption{ Ukáka zmien adresného priestoru poèas Hollowingu.}
	\label{vzhladobr}
\end{figure}

\subsection{Princíp}

Princíp ukrytia malvéru, ktorı vyuíva \textit{process hollowing} je do istej miery podobnı technike \textit{DLL Injection}. Hlavnı cie¾ metódy spoèíva v ukrytí škodlivého kódu do beného procesu, ktorı v systéme Windows spôsobuje èo najmenšie podozrenie \cite{hollowing}. Takımto procesom môe by napríklad \textit{svchost.exe}, ktorı je v systéme bene spustenı aj vo viacerıch inštanciách. \textit{Process hollowing} vytvorí pozastavenı proces \textit{svchost.exe} (prípadne získa prístup u k beiacemu procesu) a odmapuje jeho pamä. Po odmapovaní alokuje dostatok miesta vo virtuálnom adresnom priestore procesu. Následne, po alokácii nakopíruje škodlivı kód a nastaví novı vstupnı bod programu. Po ukonèení tıchto krokov obnoví pozastavenı proces. Vısledkom je navonok beiaci štandardnı proces \textit{svchost.exe}, ktorı ale vo vnútri vykonáva škodlivú èinnos. Schematické znázornenie priebehu tejto techniky môeme vidie na obrázku è.\ref{vzhladobr}.

\subsection{Vyuívané API funkcie}
\textit{Process hollowing} vyuíva na svoje fungovanie rôzne štandardné API volania. Nasledujúce nami vybrané API funkcie\cite{winapi}, môu by vyuité pri technike \textit{rocess hollowing}:
\begin{itemize}
\item
\textbf{CreateThread}
\\
Vytvorí nové vlákno vo virtuálnom adresnom priestore procesu, ktorı danú funkciu zavolal.
\item
\textbf{CreateRemoteThread}
\\
Vytvorí vlákno, ktoré beí vo virtuálnom adresovom priestore iného procesu.
\item
\textbf{CreateRemoteThreadEx}
\\
Funkcia vytvára vlákno, ktoré sa spúša vo virtuálnom adresovom priestore iného procesu a prípadne špecifikujte rozšírené atribúty, ako napr. nastavenie na ktorom procesore bude dané vlákno bea.
\\
\\
\item
\textbf{ResumeThread}
\\
Funkcia dekrementuje hodnotu, ktorá špecifikuje, ko¾krát bolo vlákno pozastavané. V prípade ak sa hodnota dostane na nulu, vlakno je obnovené. V opaènom prípade ostáva pozastavené. 
\item
\textbf{SuspendThread}
\\
Pozastavenie vykonávanie èinnosti špecifikovaného vlákna.
\item
\textbf{SwitchToThread}
\\
Spôsobuje prepnutie aktuálneho vlákna, na vlákno, ktoré je pripravené bea na procesore. Tento vıber vykonáva operaènı systém.
\item
\textbf{CreateProcessA}
Vytvorí novı proces a jeho hlavné vlákno. Novı proces beí s rovnakımi oprávneniami ako proces, ktorı danú funkciu zavolal.
\item
\textbf{VirtuallAlloc}
\\
Alokuje alebo mení oprávnenia stránok vo virtuálnom adresom priestore procesu, ktorı danú funkciu zavolal. Alokovaná pamä je automaticky inicializovaná na nulu.
\item
\textbf{VirtualAllocEx}
\\
Funguje rovnako ako \textit{VirtualAlloc}, s tım rozdielom, e alokuje pamä v rámci virtuálneho adresného priestoru iného procesu.
\item
\textbf{WriteProcessMemory}
\\
Zapisuje údaje do pamäti v zadanom procese. Celá oblas, do ktorej sa zapisuje, musí ma potrebné oprávnenia na zápis.
\item
\textbf{ReadProcessMemory}
\\
Èíta údaje z virtuálneho adresného priestoru špecifikovaného procesu.
\item
\textbf{SetThreadContext}
\\
Nastavuje kontext (t.j. obsah registrov) pre špecifikované vlákno.
\item
\textbf{ExitThread}
\\
Keï sa táto funkcia zavolá, všetky udalosti aktuálneho vlákna sa zrušia. Podobne všetky èakajúce vstupno-vıstupné udalosti iniciované vláknom sa zrušené a vlákno ukonèí svoju èinnos. 
\item
\textbf{NtUnmapViewOfSection}
\\
Odmapuje pamä vybraného procesu.
\\
\end{itemize}
\section{Existujúce riešenia na detekciu}\label{existingsolutions}
\noindent
Doposia¾ známe existujúce riešenia na detekciu techniky \textit{process hollowing} vyuívanej niektorımi vzorkami škodlivého kódu, sú urèené na forenznú analızu. Táto analıza prebieha a po infikovaní zariadenia malvérom a zistením, e škodlivı kód sa u v zariadení nachádza. Riešenia spomínané v tejto kapitole sa teda nezameriavajú na detekciu techniky v reálnom èase. 

\subsection{PHDetection}

\textit{PHDetection} h¾adá moduly, od ktorıch závisí pôvodnı spustite¾nı program \cite{phdetection}. \textit{PHDetection} kontroluje èi sú dané moduly naèítané do pamäte programu. Ak nástroj nájde moduly, na ktorıch závisí dotyènı program (t.j. sú zapísané v IAT) ale nenájde ich v pamäti procesu, \textit{PHDetection} deteguje e sa jedná o \textit{process hollowing} a pôvodnı proces bol nahradenı inım. Existuje mnoho spustite¾nıch súborov, ktoré nezávisia od ve¾kého poètu modulov a kvôli tomu nástroj analyzuje aj tabu¾ku importov, v ktorej sa nachádzajú moduly, ktoré sa majú naèíta a poèas prvého pouitia. To znamená e DLL súbor sa naèíta do pamäte procesu a v momente, kedy sa zavolá prvá funkcia z tohoto modulu. \textit{PHDetection} teda postupne prechádza všetky beiace procesy a analyzuje naèítané moduly. V prípade ak danı modul nastavenı na neskoršie naèítanie a ešte sa nenachádza v pamäti, nástroj porovnáva èasové znaèky spustite¾ného súboru na disku a v pamäti. Program bol implementovanı v jazyku C++.

\subsection{HollowFind}

\textit{Hollowfind} je plugin pre nástroj \textit{Volatility} na detekciu rôznych typov techniky \textit{process hollowing} pouívanıch škodlivım kódom \cite{hollowfind}. Plugin sa zameriava taktie na rôzne formy obfuskácie danej techniky s cie¾om saenia forenznej analızy. Plugin deteguje metódu na základe porovnávania VAD a PEB tabuliek. VAD tabu¾ka je stromová štruktúra reprezentujúca jednotlivé stránky vo virtuálnom adresnom priestore a PEB tabu¾ka obsahuje rôzne informácie o konkrétnom procese. Príkladom môe by chıbajúca cesta k spustite¾nému súboru vo VAD tabu¾ke alebo rôzne bázové adresy procesu v PEB a VAD tabu¾ke.

\section{Algoritmus na detekciu}
\noindent
\begin{figure}[!htbp]
	\centering
	\includegraphics[width=11cm]{img/Automat.jpg}
	\caption{Koneènı stavovı automat reprezentujúci postupnos API volaní vedúcich k ukrytiu malvéru.}
	\label{automat}
\end{figure}

Nami navrhnutı algoritmus na detekciu techniky \textit{process hollowing} je zaloenı na koneènom stavovom automate. Automat tvorí celkovo šes prechodovıch stavov (a jeden poèiatoènı a jeden koneènı stav). Cez tieto stavy postupne prechádzame pri zachytávaní niektorıch API volaní. Automat obsahuje nasledujúce stavy:
\begin{itemize}
	\item \textbf{Vytvorenie pozastaveného procesu}
	\item \textbf{Odmapovanie pamäte}
	\item \textbf{Alokácia pamäte}
	\item \textbf{Skopírovanie škodlivého kódu}
	\item \textbf{Nastavenie IP}
	\item \textbf{Spustenie procesu}
\end{itemize}

Vstupné symboly, ktoré spôsobujú prechody v koneènom automate sú v našom prípade API volania. Nami zvolené API volania môeme rozdeli do nasledujúcich skupín:

\begin{itemize}
\item
\textbf{WAPI1} -
sú API funkcie, ktoré umoòujú vytvára nové vlákna/procesy alebo získa prístupy do u existujúcich vlákien/procesov, t.j. \textit{CreateThread}, \textit{SuspendThread}, \textit{CreateProcessA}.
\item
\textbf{WAPI2} -
predstavujú API volania primárne urèené na odmapovanie pamäte existujúceho procesu, t.j. \textit{NtUnmapViewOfSection}.
\item
\textbf{WAPI3} -
volania slúiace na alokáciu pamäte vo virtuálnom adresnom priestore procesu, t.j. \textit{VirtualAlloc}, \textit{VirtualAllocEx}.
\item
\textbf{WAPI4} -
tieto funkcie umoòujú manipulova s pamäou;kopírovanie pamäte, zapisovanie a èítanie, t.j. \textit{WriteProcessMemory}, \textit{CopyMemory}, \textit{ReadProcessMemory}.
\item
\textbf{WAPI5} - API volanie, ktoré nastavuje kontext daného vlákna a umoòujú nastavi IP - \textit{SetThreadContext}. 
\item
\textbf{WAPI6} -
poslednou skupinou sú API volania, ktoré spúšajú pozastavené vlákno, t.j. \textit{ResumeThread}.
\end{itemize}

Algoritmus na detegovanie funguje na jednoduchom princípe. Podozrivú vzorku spustíme a zachytávame vyššie spomínané API volania. Na základe tıchto volaní postupne prechádzame stavmi koneèného automatu. Ak sa postupne dostaneme dostaneme do posledného stavu, prepokladáme e nastal \textit{process hollowing}. Celkové znázornenie automatu môeme vidie na obrázku è.\ref{automat}.

\subsection{Koneènı stavovı automat}

Koneènı automat je teoretickı vıpoètovı model pouívanı v informatike na štúdium rôznych formálych jazykoch. Popisuje ve¾mi jednoduchı poèítaè, ktorı môe by v jednom z nieko¾kıch stavov, medzi ktorımi prechádza na základe symbolov, ktoré èíta zo vstupu. Mnoina stavov je koneèná , koneènı automat nemá iadnu ïalšiu pamä, okrem informácie o aktuálnom stave. V informatike sa rozlišuje okrem základného deterministického èi nedeterministického automatu tie Mealyho a Moorov automat.

Koneènı automat je definovanı ako usporiadaná pätica (S, $\Sigma$ , $\sigma$, s, F) kde:\\
S je koneèná neprázdna mnoina stavov. \\
$\Sigma$ je koneèná neprázdna mnoina vstupnıch symbolov, nazıvaná abeceda.\\
$\sigma$ je prechodová funkcia respektíve prechodová tabu¾ka popisujúca prechod medzi jednotlivımi stavmi.\\
s je poèatoèná stav patriaci do mnoiny stavov S.\\
F je mnoina finálych akceptujúcich stavov.\\

Na zaèiatku sa automat nachádza v definovanom poèiatoènom stave. Ïalej v kadom kroku preèíta jeden symbol zo vstupu a prejde do stavu, ktorı je danı hodnotou, ktorá v prechodovej tabu¾ke zodpovedá aktuálnemu stavu a preèítanému symbolu. Potom pokraèuje èítaním ïalšieho symbolu zo vstupu, ïalším prechodom pod¾a prechodovej tabu¾ky atï.

Pod¾a toho, èi automat skonèí po preèítaní vstupe v stave, ktorı patrí do mnoiny prijímajúcich stavov, platí, e automat buï danı vstup prijal, alebo neprijal. Mnoina všetkıch reazcov, ktoré danı automat príjme, tvorí regulárny jazyk.

V našom prípade abecedu tvorí mnoina nami vybranıch API windows funkcií, ktoré by potenciálne mal najèastejšie vyuíva malvér vyuívajúci techniku \textit{Process Hollowing} na ukrytie svojej èinnosti. 

\subsection{Matica koneèného stavového automatu}
Matica reprezentuje prechody medzi jednotlivımi stavmi koneèného stavového automatu. Tieto prechody sú definované ako volania vybranıch API funkcií, ktoré posúvajú automat cez jednotlivé stavy pod¾a toho v akom stave je aktuálne automat a do akého nového stavu sa automat dostane. Koneèná mnoina stavov je reprezentovaná stavmi \textbf{štart}, \textbf{vytvorenie procesu}, \textbf{alokácia pamäte}, \textbf{kopírovanie malvéru}, \textbf{nastavenie IP} a \textbf{spustenie vlákna}. Poèiatoènı stav automatu je \textbf{štart} a koneènı stav je \textbf{process hollowing}, ktorı oznaèuje e nastalo injektovanie kódu.

\begin{table}[!htbp]
	\begin{center}
		\begin{tabular}{p{5cm}|c|c|c|c|c|c|c}
			& \multicolumn{7}{c}%
			{\textbf{Prechodové stavy}}\\ \hline
			\textbf{Volané API funkcie} &\begin{sideways} Štart \end{sideways} &\begin{sideways} Vytvorenie procesu/ Získanie prístupu do procesu \end{sideways} &\begin{sideways} Odmapovanie pamäte existujúceho procesu \end{sideways} &\begin{sideways} Alokácia virtuálnej pamäte \end{sideways} & \begin{sideways} Kopírovanie malvéru do alokovanej pamäte \end{sideways} & \begin{sideways} Nastavenie IP na spustenie malvéru \end{sideways} & \begin{sideways} Spustenie vlákna/ Spustenie pozastaveného procesu \end{sideways}  \\ \hline
			Skratky stavov & S0 & S1 & S2 & S3 & S4 & S5 & S6 \\ \hline
			CreateThread & S1 & S1 & S1 & S1 & S1 & S1 & S1 \\ \hline
			CreateRemoteThread & S1 & S1 & S1 & S1 & S1 & S1 & S1 \\ \hline
			CreateRemoteThreadEx & S1 & S1 & S1 & S1 & S1 & S1 & S1 \\ \hline
			CreateProcessA & S1 & S1 & S1 & S1 & S1 & S1 & S1 \\ \hline
			CreateProcessW & S1 & S1 & S1 & S1 & S1 & S1 & S1 \\ \hline
			SwitchToThread & S1 & S1 & S1 & S1 & S1 & S1 & S1 \\ \hline
			OpenThread & S1 & S1 & S1 & S1 & S1 & S1 & S1 \\ \hline
			SuspendThread & S1 & S1 & S1 & S1 & S1 & S1 & S1 \\ \hline
			NtUnmapViewOfSection & S0 & S2 & S2 & S3 & S4 & S5 & S6 \\ \hline
			VirtualAlloc & S0 & S1 & S3 & S3 & S4 & S5 & S6 \\ \hline
			VirtualAllocEx & S0 & S1 & S3 & S3 & S4 & S5 & S6 \\ \hline
			CopyMemory & S0 & S1 & S2 & S4 & S4 & S5 & S6 \\ \hline
			WriteProcessMemory & S0 & S1 & S2 & S4 & S4 & S5 & S6 \\ \hline
			ResumeThread & S0 & S1 & S2 & S3 & S4 & S6 & S6 \\ \hline
			ExitThread & S0 & S1 & S2 & S3 & S4 & S6 & S6 \\ \hline
			SetThreadPriority & S0 & S1 & S2 & S3 & S5 & S5 & S6 \\ \hline
			
		\end{tabular}
		\caption{Matica prechodov medzi stavmi pri volaniach API.}
		\label{maticaPrechodov}
	\end{center}
\end{table}

\section{Implementácia}\label{implementation}

Pre implementáciu riešenia sme zvolili programovanı jazyk C++, pretoe primárnym testovavím prostredím budú najèastejšie pouívané systémy Windows. Na simuláciu testovanie prostredia pouijeme \textbf{Virtual Box} v ktorom budeme simulova bené pouívanie systému.
Zvolené vıvojové prostredie je \textbf{Visual Studio 2019}, ktoré nám umoòuje pracova s najnovšími verziami systému a aj u¾ahèi jednuduchšiu implementáciu algoritmu.

\begin{figure}[!htbp]
	\centering
	\includegraphics[width=12cm]{img/UML2.jpg}
	\caption{Moduly aplikácie}
	\label{UMLDiagram}
\end{figure}

Práca sa zaoberá návrhom a implementáciou spôsobu detegovania techniky \textit{Process Hollowing}, ktorú vedia vyuíva niektoré malvéry. Aplikácia urèená na detegovanie, bude bea v reálnom èase, teda je schopná detegova \textit{Process Hollowing} poèas jeho behu. Vstupné dáta do tejto aplikácie budú predstavova volané API funkcie procesom a z tıchto API funkcií bude aplikácia vyhodnocova a poskytova vısledky. Aplikácia bude pozostáva z nasledujúcich èastí. Mutex, ktorı bude zabezpeèova plynulos a bezpeènos programu. Modul na injectovanie DLL, ktorı bude vklada DLL kninicu na odchytávanie volanıch API. Modul na vyhodnocovanie prítomnosti \textit{Process Hollowing-u}, ktorı sa skladá z viacerıch èastí. Modulu na naèítanie najnovších záznamov z DLL kninice. Koneèného stavového automatu reprezentovaného maticou, oproti ktorej bude aplikácia porovnáva prechody medzi jednotlivımi stavmi pod¾a volanıch API. Archiváciou, ktorá zabezpeèí archiváciu dát po preèítaní najnovších záznamov z DLL kninice. A vyhodnocovacou funckiou, ktorá bude vyhodnocova kedy sa prechodnı stav nastaví do koneèného stavu a oznaèí vzorku za pozitívnu. 
\subsection{Algoritmus}

\begin{figure}[!htbp]
	\centering
	\includegraphics[width=9cm]{img/UML.jpg}
	\caption{UML diagram vyvıjaného algoritmu.}
	\label{UMLDiagram}
\end{figure}
\noindent
\\
Aplikácia na zaèiatku inicializuje mutex, ktorı slúi slúi na koordináciu viacerıch procesov, ktoré vyadujú prístup k rovnakému objektu súèastne.  Následne aplikácia spustí modul na zber na dát, ktorı monitoruje aké API sa volajú v systéme Windows. Pre jednoduchšie monitorovanie vyuívame vo¾ne dostupnú kninicu \textit{Detours}. Aplikácia si nastaví poèiatoènú hodnutu prechodného stavu, ktorı slúi na vyhodnocovanie prítomnosti \textit{Process Hollowing-u}. Po nastavení všetkıch poèiatoènıch hodnôt aplikácia prejde na samotnú detekciu. Vlákno sa uspí na stanovenú dobu a po nastavení mutexu zaèína aplikácia samotnı proces detegovania. Aplikácia si naèíta najnovšie záznami z modulu na zber dát. Zo záznamu aplikácia vyberie volanú API funkciu a zisuje èi k danej API existuje hodnota v matici koneèného automatu. Ak áno, aplikácia zisuje aktuálny prechodnı stav a následne, pomocou koneèného stavového automatu novú hodnotu na ktorú sa prechodnı stav následne zmení. Po vykonaní zmeny nastane kontrola na existenciu ïalších záznamov v súbore ak súbor obsahuje ïalšie záznami, naèíta si ïalší záznam a proces sa opakuje. Ak u aplikácia naèítala všetky záznami spraví sa archivácia záznamov a aplikácia vyhodnocuje prechodnı stav koneèného stavového automatu. Ak prechodnı stav nieje v koneènom stave mutex sa uvo¾ní a aplikácia èaká na ïalšie záznami z modulu na zber dát a cyklus sa opakuje. Keï sa prechodnı stav dostane do koneèného stavu aplikácia oznámi existenciu \textit{Process Hollowing-u} a ukonèí sa.  
\subsection{Modul na zber dát}
\noindent

Modul na zber dát predstavuje DLL kninicu (\textbf{Hook.dll}) vyuívanú na vloenie do vybraného procesu, cez ktorú sa následne odchytávajú vybrané API funkcie zapísaním do textového súboru. Modul sa skladá z dvoch èastí. Prvá èas predstavuje definície vybranıch API funkcií, ku ktorım je následne definované aj ich pôvodné volanie. Okrem volania konkrétnej API funkcie aj do pripraveného textového súboru zapíše èas a volanú API funkciu vo \textbf{writeFunctionToFile}, ktoré sú následne pouité v aplikácii na detegovanie prítomnosti \textit{Process Hollowing-u} v beiacom procese. 

\begin{lstlisting}[caption=Implementácia funkcie writeFunctionToFile.,label={vypis1}]
void writeFunctionToFile(std::string originalFunkcion) 
{
	DWORD ret = WaitForSingleObject(hMutex, INFINITE);
	
	if (ret == WAIT_OBJECT_0)
	{
		time_t now = time(NULL);
		tm* ltm = localtime(&now);
		std::ofstream myFile("api_data.txt", std::ofstream::app | std::ofstream::out);
		
		if (myFile.is_open())
		{
			myFile << ltm->tm_hour << ":" << ltm->tm_min << ":" << ltm->tm_sec << ";" + originalFunkcion << endl;
			myFile.close();
		}
		
		ReleaseMutex(hMutex);
	}
}
\end{lstlisting}
Druhá èas aplikácie u slúi len na nahradenie pôvodnej volanej API funkcie (modifikovanou funkciou), ktorá je rozšírenia o zapisovanie volanej API do súboru. Pôvodnú funkciu \textit{SetThreadContext} urèenú na nastavenie \textit{Instriction Pointer} v tomto module nahradíme funkciou \textit{HookSetThreadContext}, ktorá okrem volania pôvodnej funkcie volá aj funkciu \textbf{writeFunctionToFile} na zapísanie API funkcie do predpripraveného súboru.
\begin{lstlisting}[caption=Definícia API volania SetThreadContext.,label={vypiS3}]
static BOOL(__stdcall *RealSetThreadContext)(HANDLE, const CONTEXT*) = SetThreadContext;

BOOL WINAPI HookSetThreadContext(HANDLE hThread, const CONTEXT* lpContext)
{
	writeFunctionToFile("SetThreadContext");
	return RealSetThreadContext(hThread, lpContext);
}
\end{lstlisting}

\begin{lstlisting}[caption=Nahradenie pôvodnej funkcie SetThreadContext.,label={vypiS4}]
switch (ul_reason_for_call)
{
	case DLL_PROCESS_ATTACH:
	{
		DetourAttach(&(PVOID&)RealSetThreadContext, HookSetThreadContext);
		DetourTransactionCommit();
		break;
	}
	case DLL_PROCESS_DETACH:
	{
		DetourDetach(&(PVOID&)RealSetThreadContext, HookSetThreadContext);
		DetourTransactionCommit();
		break;
	}
}
\end{lstlisting}

\begin{lstlisting}[caption=Inicializácia mutexu.,label={vypiS5}]
HANDLE mutexOnThreadSafe;
mutexOnThreadSafe = CreateMutex(NULL, FALSE, TEXT("MutexOnThreadSafe"));

\end{lstlisting}

\subsection{Detours}
\textit{Detours} je kninica urèená na monitorovanie a inštruovanie API volaní v systéme Windows. Táto kninica podporuje rovnako 32 tak aj 64 bitovú verziu Windowsu. \textit{Detours} u¾ahèuje prácu vıvojárom, ktorı pracujú s rozhraním API volaní. Je k dispozícii na základe \textit{Open source} licencie a je vo¾ne dostupnı pre komunitu.
Kninica sa aplikuje dynamicky za behu programu. Detours nahrádza pokyny cie¾ovej funkcie skokom na pouívate¾om zadanú  funkciu. Kód cie¾ovej funkcie je modifikovanı v pamäti, nie na disku, èo umoòuje zachytávanie binárnych funkcií. \cite{detours} Po naèítaní do procesu môe DLL kninica obís akúko¾vek funkciu v procese, ako sú napríklad rozhrania Windows API.

\section{Vısledky}\label{results}
Našu aplikáciu budeme testova vo \textit{Virtual Boxe}, na systéme Windows 10. Aplikáciu budeme testova na reálych vzorkách malvéru, ktoré vyuívajú \textit{Process Hollowing}. na ukrytie svojej èinnosti. Pred testami sme aplikáciu testovali na vzorke dostupnej na GitHube\cite{gitHub}, ktorá bola ukákou ako vyzerá \textit{Process Hollowing}
\subsection{Experiment a vyhodnotenie}
Experiment bude pozostáva z reálnych vzoriek malvérov, ktoré vvyuívajú \textit{Process Hollowing} na ukrytie svojej èinnosti. Vzorky vyh¾adáme na internetovıch stránkach VirusTotal\cite{virusTotal} a ANY.RUN\cite{anyRun}, kde sú vo¾ne dostupné. Na stránke VirusTotal sme schopní nájs potrebné heše, pomocou ktorıch sme schopní doh¾ada vzorky na ANY.RUN, ktoré môu vyuíva \textit{Process Hollowing}. 

\begin{table}[!htbp]
	\begin{center}
		\begin{tabular}{p{4,5cm}|c|c|c}
			\textbf{Názov vzorky} &  \textbf{MD5 Identifikátor}  & \textbf{Stav} & \textbf{Èas}\\ \hline
			MSIL/Injector.DXQ & 706630a77f06ef8fb90eb312fa2cbfe6 & Y & 2,203s\\ \hline
			MSIL/Kryptik.FQF & 3f385d11f6b438ea963cd49e818b9d90 & Y & 1,655s\\ \hline
			MSIL/Injector.DXQ & 9e298807729dff89b56f68f4d42ffd93 & Y & 1,101s \\ \hline
			Win32/Spy.Zbot.JF & 3cfc97f88e7b24d3ceecd4ba7054e138 & N & \\ \hline
			Win32/Kryptik.AVWC & 0d42179ff6c448697b67056aecc91c67 & N & \\ \hline
			Win32/Spy.Zbot.YW & EC2DACDBCF194C1E8C8DB2DBEC605B83 & N & \\ \hline
			Win32/Kryptik.GLKL & 6c129b7ed58900286d6cd3a4e85ca15b & N & \\ \hline
			Win32/Filecoder.Natas.A & f592e7faba96a23ee25ff25f3779f44f & N &\\ \hline	
		\end{tabular}
		\caption{Vybrané vzorky, stav a èas detegovania.}
		\label{vzorky}
	\end{center}
\end{table}

Tieto vzorky sme podrobili testom vo Virtual Boxe na operaènom systéme Windows 10. Do predprivaného adresára sme si pripravili aplikáciu ako aj vzorky. Po spustení \textbf{DetectionApp}, aplikácia injektovala DLL do vybranej vzorky a následne spustila detegovanie. Èasovı limit na jednú vzorku sme si stanovili na 5 minút. Ak za tento èas aplikácia neohlásila existenciu \textit{Process Hollowing-u} vzorku sme oznaèili ako negatívnua proces ukonèili. Kadá vzorka, kde aplikácia prešla koneènım automatom a do posledného stavu bola oznaèená ako pozitívna. Aplikácia vyhlásila existenciu \textit{Process Hollowing-u} a vypísala èas, ktorı ubehol od injektovania DLL kninice a po pozitívne oznaèenie. Jednotlivé vzorky, stavy(ak bola vzorka oznaèená Pozitívna/Negatívna) a èasy detegovania sú zaznaèené v tabu¾ke è. \ref{vzorky}.

\subsection{Vyhodnotenie vısledkov testovania}

Z nami vybranıch vzoriek aplikácia oznaèila za pozitívne tri vzorky, zvyšné oznaèila za negatívne. Ako si môeme všimnú v tabu¾ke è. \ref{vzorky} èas detegovania v prípade troch pozitívne oznaèenıch vzoriek bol krátky. Tieto tri vzorky boli algoritmom vyhodnotené ako pozitívne na prítomnos \textit{Process Hollowing-u}. Niektoré vybrané vzorky, ktoré boli oznaèené za negatívne, môu indikova neprítomnos \textit{Process Hollowing-u}.

Dôvodov na oznaèenie vzoriek za negatívne aj keï zdroje ukazujú opak, môe by viacero. Samotná vzorka môe by len prechodné úloisko, ktoré môe vytvára novı proces, ktorı u ale \textit{Process Hollowing} vykoná v inom procese ako je nami sledovanı proces. Vzorka môe na svoju úspešnos potrebova internetové pripojenie kde si stiahne ïalšie potrebné veci, alebo kde môu by uloené ïalšie dáta poprípade inštrukcie potrebné na vykonanie procesu ale spojenie s danım serverom je neúspešné. Nami navrhnutı koneènı stavovı automat nemusí obsahova API, ktoré síce umoòia vytvori \textit{Process Hollowing} ale neumonia algoritmu detegova prechod do ïalšieho prechodového stavu.
