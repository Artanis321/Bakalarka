% !TeX spellcheck = sk_SK
\section{Malvér}
\noindent

\noindent Je to softvér, ktorého cie¾om je poškodi, zablokova, zmocni sa alebo odcudzi citlivé informácie uloené v poèítaèi. Cie¾om malvéru je získa informácie pre útoèníka a následné zneuitie tıchto informácií na rôzne druhy nelegálnej èinnosti za úèelom danej obeti uškodi alebo sa na nej finanène obohati. Malvér sa kedysi èlenil na rôzne kategórie ako napr. vírusy, \textit{backdoor}, \textit{spyware}, \textit{ramsomware} a pod.\cite{malvare} V súèasnosti u toto delenie nie je ve¾mi aktuálne, pretoe malvér v dnešnej dobe je u viacmenej kombináciou tıchto kategórií a vyuíva rôzne komponenty z jednotlivıch druhov škodlivého kódu. V nasledujúcej kapitole sa podrobnejšie zaoberáme rôznymi spôsobmi ukrıvania èinnosti a prítomnosti malvéru, ktoré môu by v súèasnosti vyuívané.
\vspace{20px}
\subsection{Techniky ukrıvania èinnosti}
\noindent 
Malvér vo všeobecnosti patrí ku škodlivému kódu. Preto je nutné jeho beiace procesy utaji. Ak chce by malvér úspešnı v získavaní údajov alebo finanènıch prostriedkov, musí by jeho beh ukrytı pred potenciálnym antivírusom, prípadne forenznım ininierom ktorı je schopnı ho odhali. Za tımto úèelom sa vyuívajú rôzne techniky na ukrytie malvéru buï v pamäti poèítaèa, rôznych shell scriptoch alebo dynamickıch kniniciach, aby boli èo najmenej detegovate¾né.

\begin{itemize}
	\item 
\textbf{DLL Injection / Reflective DLL Injection}
\noindent \\ \textit{DLL Injection} je technika pouívaná na ukrytie funkcie na spustenie malvéru vo vnútri iného programu. Najastejšie sa na to vyuíva alokovaná pamä vyhradená pre beh infikovaného programu, kde sa funkcia na spustenie malvéru ukryje a pre antivírusové programy je ako detekovate¾ná. Po nakopírovaní DLL funkcie do alokovanej pamäte iného programu môe by následne vyvolané spustenie infikovaného programu a spolu s ním aj spustenie malvéru. Hlavnım cie¾om \textit{DLL Injection} je škodlivı kód ukry do oficiálneho alebo overeného programu, kde je malvér ukrytı pred antivírovım softvérom, odkia¾ môe by následne spustenı. \cite{endgame}

\item 
\textbf{Proces Hollowing}
\noindent \\ vyuíva rovnaké alebo podobné princípy ukrıvania škodlivého softvéru ako \textit{DLL Injection}. Cie¾om je schova škodlivı kód do existujúce programu z ktorého sa po spustení, spustí aj volanie škodlivého malvéru.  Oproti \textit{DLL Injection} ide ale ukrytie malvérového programu do iného programu. Malvér si pod¾a potreby alokuje virtuálnu pamä  v pamäti iného programu. Po spustení infikovaného programu malvér pozastaví vlákno v ktorom program beí, následne zmení obsah legitímneho súboru zmapovaním pamäte cie¾ového procesu.\cite{endgame} Po zmapovaní uvo¾ní všetku pamä programu a alokuje pamä pre malvér a zapíše kadú z èastí malvéru do cie¾ovej pamäte programu. Malvér nastaví kontext vo vlátkne tak aby ukazoval vstupnı bod na novú èas kódu, ktorú napísal. Na konci malvér obnoví pozastavené vlákno, aby sa proces dostal z pozastaveného stavu a nasledovnım spustením programu umoní získavanie údajov.

\item 
\textbf{Thread Execution Hijacking }
\noindent \\
Táto technika ukrytia malvéru spoèíva v napojení sa na u existujúce vlákno vyvolanı inım programom. Po získaní prístupu do vlákna malvér uvedie vlákno do pozastaveného reimu aby vykonal vloenie volania škodlivého malvéru do vlákna iného procesu. Malvér si alokuje virtuálnu pamä v programe a následne do tejto pamäte vloí škodlivı shell kód, ktorı obsahuje cestu k volaniu DLL so škodlivım malvérom.  Po vykonaní tıchto úkonov, spustí pozastavené vlákno programu. Nevıhodou takéhoto spustenia pozastaveného programu je, e môe spôsobi zlyhanie systému v rámci systémového volania. \cite{endgame} Preto aby sa tomu predišlo modernejší malvér proces ukonèí a vyvolá ho znovu s u modifikovanou zmenou na infikovanie.

\item 
\textbf{Portable Executable Injection}
\noindent \\ 
Vıhodou tohto spôsobu ukrytia malvéru je vyuitie nakopírovania malvéru do u existujúceho beiaceho procesu pomocou shell skriptu\cite{endgame}, ktorı vyvolá spustenie škodlivého malvéru. Namiesto toho aby proces prepisoval cesty volaním  DLL, táto technika zapisuje obsah malvéru priamo do pamäte. Poèas doby zapisovania aby malvér nebol ¾ahko odhalenı vyuíva vnorené cykly, ktoré spoma¾ujú systém buï diagnostikou alebo volaním zbytoènıch funkcií a snaí sa zahlti systém a neumoni skorú diagnostiku malvéru. Keï malvér preformuluje všetky potrebné adresy, všetko, èo musí urobi, je odovzda jeho poèiatoènú adresu vláknu a necha spusti malvér.

\item 
\textbf{Hook injection}
\noindent \\
Hook injection je technika pouívaná na zachytávanie volania funkcií. Malvér môe vyuíva hook injection funkcie na naèítanie škodlivého súboru v DLL pri spustení udalosti v konkrétnom vlákne. Malvér na to vyuíva volanie funkcie, ktorı obsahuje štyri parametre.\cite{endgame} Prvı je tip udalosti na, ktorı sa spustí škodlivı malvér napríklad na stlaèenie klávesnice alebo tlaèidla na myši. Druhı je ukazovate¾ na funkciu, ktorá sa ma po stlaèení daného tlaèidla vykona. Tretí je modul obsahujúci danú funkciu. Preto je pred volaním funkcie, vidie volania do LoadLibrary. Poslednı parameter je vlákno ktoré má vykona procedúru a hook injection. Pokia¾ je poslednı parameter prázdny alebo nastavenı na nulu tak danú procedúru vykonajú všetky beiace vlákna.  Malvér sa ale zameriava len na jedno vlákno, kvôli zníeniu detekcii svojej práce.

\item 
\textbf{APC Injection}
\noindent \\
Škodlivı softvér môe vyuíva vıhody asynchrónnych volaní procedúr (APC), aby prinútil ïalšie vlákno spusti svoj vlastnı kód jeho pripojením do fronty cie¾ového vlákna.\cite{endgame} Kadé vlákno má rad asynchrónnych volaní procedúr, ktoré èakajú na vykonanie, keï cie¾ové vlákno vstupuje do zmenite¾ného stavu. Vlákno vstúpi do vıstraného stavu. Malvér zvyèajne h¾adá akéko¾vek vlákno, ktoré je v zmenite¾nom stave, aby zaradil APC do vlákna. Èo umoòuje jeho následnım spustením infikova zariadenie malvérom.

\item 
\textbf{Extra windows memory injection}
\noindent \\
Tento spôsob schovávania softvéru sa spolieha na rozširovanie pamäte aplikaènıch okien v systéme. Pri otváraní nového okna aplikácie, softvér špecifikuje ïalšie bajty pamäte, ktoré rozšíria ve¾kos alokovanej pamäte pre spustenú aplikáciu.\cite{endgame} Tento proces sa nazıva \textit{Extra Windows Memory}(EWM). V tejto èasti ale nevzniká dostatok miesta na uloenie údajov. Aby sa toto obmedzenie obišlo, škodlivı softvér zapíše kód do zdie¾anej sekcie aplikácie a do EWM vloí ukazovate¾ na danú èast. Do tejto rozšírenej èasti zie¾anej pamäte ïalej softvér zapíše ukazovate¾ funkcie do pamäte, ktorá obsahuje shell skript na spustenie malvéru. Malvér následne nastaví v EWM fukciu na zmenu hodnôt na zadanom ofsete. Èím malvér môe jednoducho zmeni posun ukazovate¾a funkcie pamäti aplikácie a nasmerova ho do EWM, na kód so škodlivım shell skriptom.
\end{itemize}
\vspace{20px}
\subsection{Súèasnı malvér}
\noindent \\
Táto kapitola obsahuje opis jednotlivıch malvérov pouívanıch v roku 2019, ktoré boli detekované spoloènosami ako Avast a McAfee. Tieto malvéry sú najèastejšie vyuívané v oblasti Európy. Kapitola obsahuje bliší opis malvérov, ich vyuitie, pouité spôsoby úrokov a ukrytie malvéru v systéme.

\begin{itemize}
\item
\textbf{Sodinokibi}
\noindent \\
Tento malvér bol detekovanı v období okolo apríla 2019. Patrí do rodiny ransomvéru, ktorıch cie¾om je šifrova informácie v zariadení a následne za dešifrovanie pıta nemalı obnos peòazí.\cite{sinobiki} Názov bol objavenı v hash kóde, ktorı obsahoval názov "Sodinokibi.exe". vírus sa šíri sám zmeuívaním zranite¾nosti na serveroch Oracle WebLogic. Softvér je navrhnutı tak, aby rıchlo vykonával šifrovanie definovanıch súborov v konfigurácii ransomvéru. Prvou akciou škodlivého softvéru je získa vetky funkcie potrebné pri  behu programu a vytvori dynamickı IAT, ktorı sa pokúsi zahlti volanie systému Windows statickou analızou. Po zahltení systému dôjde k spusteniu malvéru. Technika vyuívaná na ukrytie malvéru je Portable Executable Injection ktorú volá po spomalení RunPE na jej spustenie z pamäte. táto technika ukrytia malvéru je opísaná v predošlej kapitole. Analıza spoloènosti McAfee ukazuje podobnos s inım starším malvérom GandCrab.(prida odkaz na analızu respektíve literatúru)

\item
\textbf{Emotet}
\noindent \\
Emotet je malvér, ktorı sa primárne šíri pomocou rôznych spam emailov.\cite{emotet2} Na infikovanie zariadenia pouíva rôzne skripty, makrá v dokumetoch alebo linky. Emotet stavia na infikovaní pomocou sociálneho ininierstva. Prezentuje sa ako hodnovernı zástupca napr. banky, Rôznych internetovıch obchodov, atï. . Emotet malvér sa prvıkrát objavil v roku 2014 kedy vyuíval na infikovanie rôzne JavaScript súbory.\cite{emotet} V roku 2019 sa tento vírus objavil znova tentokrát v pokroèilejšej verzii.  V novej verzii je Emotet polymorfnım malvérom èo mu umoòuje vyhnú sa klasickej detekcii. Emotet pouíva modulárne kninice Dynamic Link (DLL) na nepretritı vıvoj a aktualizáciu svojich schopností. Emotet môe navyše generova falošné indikátory, ak je spustenı vo virtuálnom prostredí èo zhoršuje jeho detekciu  systéme.

\item
\textbf{ZeuS}
\noindent \\
Prvıkrát odhalenı v roku 2007 sa Zeus Trojan, ktorı sa èasto nazıva Zbot, stal jednım z najúspešnejších kúskov botnetového softvéru na svete, postihol milióny poèítaèov a vytvoril mnostvo podobnıch kusov škodlivého softvéru vytvoreného z jeho kódu. Po jeho minimalizovaní sa znovu objavil v pozmenenej podobe so zameraním na odchytávanie bankovıch operácii (Odchytávanie prihlasovacích údajov do internet bankingu).\cite{zeuS3} Dosahuje to prostredníctvom monitorovania webovıch stránok a zaznamenávania klávesov, keï malvér zistí, e sa pouívate¾ nachádza na bankovej webovej stránke, zaène zaznamenáva stlaèenia klávesov pouité na prihlásenie. To znamená, e trójsky kôò dokáe obís zabezpeèenie na tıchto webovıch stránkach. Infekcia prebieha pomocou spamov. Keï uívate¾ klikne na odkaz v správe alebo stiahne obsah súboru. spolu s ním stiahne a spustí aj makro. Ktoré po nainštalovaní umoòuje sledovanie zariadenia. 

\item
\textbf{Dridex}
\noindent \\
Dridex je známy trójsky kôò, ktorı sa špecializuje na kráde kreditnıch údajov online bankovníctva. Tento typ škodlivého softvéru sa objavil v roku 2014 a stále napreduje a vyvíja. Novı variant Dridex je schoplnı vyhnú sa detekcii tradiènımi antivírusovımi produktami.  Dridex tie zvıšil svoju infraštruktúru kniníc, ktoré pouívajú názvy súborov naèítané legitímnymi spustite¾nımi súbormi systému Windows. Názvy súborov a hash sa však obnovujú a menia zakadım, keï sa obe prihlási do infikovaného hostite¾a Windows. Tento malvér je v súèastnosti schopnı detekova pribline 25 a 30 percent aktuálnych antivírusovıch softvérov. 

\item
\textbf{Mirai}
\noindent \\
\textit{Mirai} je samo sa mnoiaci vírus botnetov. Zdrojovı kód pre \textit{Mirai} bol autorom verejne sprístupnenı po úspešnom a dobre propagovanom útoku na webovú stránku Krebbs. Kód botnetu Mirai infikuje zle chránené internetové zariadenia pomocou telnetu (sieovı komunikaènı protokol zaloenı na TCP) na nájdenie tıch, ktoré stále pouívajú svoje predvolené uivate¾ské meno a heslo. Úèinnos systému \textit{Mirai} je spôsobená jeho schopnosou infikova desiatky tisíc tıchto nezabezpeèenıch zariadení a koordinova ich tak, aby zaèali útok DDoS proti vybranej obeti. \cite{mirai}

Mirai má dve hlavné zloky, samotnı vírus a velite¾ské a kontrolné stredisko (CnC). CnC je samostatnı obraz, ktorı ovláda kompromitované zariadenia (BOT) a posiela im pokyny na spustenie jedného z útokov proti jednej alebo viacerım obetiam. Proces skenera prebieha nepretrite na kadom infikovanom PC pomocou protokolu telnet (na porte TCP 23 alebo 2323)

CnC predstavuje jednoduché rozhranie príkazového riadku, ktoré umoòuje útoèníkovi urèi algoritmus, IP adresu obete a trvanie útoku. CnC tie èaká na to, aby jej existujúce BOT-y vrátili novoobjavené adresy zariadení a poverenia, ktoré pouíva na skopírovanie vírusového kódu a následne na vytváranie novıch BOT-ov.Algoritmy sú konfigurovate¾né z CnC, ale v predvolenom nastavení má \textit{Mirai} tendenciu náhodne rozde¾ova rôzne polia (ako sú èísla portov, poradové èísla, identifikátory atï.).

\item
\textbf{Osiris}
\noindent \\
Osiris je potomkom malvéru Kronos, ktorı sa zameriaval na bankovnívctvo. Podobne ako Kronos je Osiris modernejšou verziou bankového trójskeho koòa.\cite{osiris} Táto verzia malvéru vyuíva na skrıvanie metódu process hollowing. Umoòuje mu predsieranie legitımnych procesov v programe a tım sauje jeho detekciu, no niektoré antivírusy ho nie sú schopné detekova. Malvér spúša svoj útok vydávaním sa za legitímny spustite¾nı súbor. (Útoky zaznamená s malvérom Osiris boli dokumenty Microsoft Wordu.) Keï je spustenı malvér na infikovanie zariadenia vyuíva dinamické kninice, ktoré obsahujú škodlivı kód. Vydávanie sa za inı oficiálny softvér znaène sauje identifikáciu malvéru a obmedzuje monosti na zastavenie útoku.\cite{osiriS3} Malvér v dokumetoch Word obsahoval aj makrá, ktoré po spustení stiahli další škodlivı malvér, ktorı umouje zahåti zariadenia, sai detekciu a rozširova útok.

\item
\textbf{Loki}
\noindent \\
Loki je ïalším potomkom staršieho malvéru Kronos, rovnako ako Osiris aj Loki vyuíva na svoje ukrytie metódy podobné process hollowing na zahltenie procesov a vydávanie sa za legitímny softvér. Loki sa zameriava na krádee osobnıch údajov, zaujíma sa najmä o prihlasovacie údaje a heslá. Od augusta 2018 a do súèasnosti sa Loki zameriava na firemné poštové schránky prostredníctvom phishingovıch a spamovıch e-mailov. Phishingové e-maily zahàòajú prílohu súboru s príponou .iso, ktorá sahuje a spúša škodlivı softvér Trojan, ktorı ukradne heslá z preh¾adávaèov, pošty, klientov File Transfer Protocol (FTP), aplikácií na odosielanie správ a kryptomennıch peòaeniek.
\end{itemize}
\begin{table}[!htbp]
	\begin{center}
		\begin{tabular}{p{4cm}|c|c|c|c|c|c|c|c}
			& \multicolumn{7}{c}%
			{\textbf{Technika ukrıvania}}\\ \hline
			\textbf{Názov malvéru} &\begin{sideways} Sodinokibi \end{sideways} &\begin{sideways} Emotet \end{sideways} &\begin{sideways} ZeuS \end{sideways} & \begin{sideways} Dridex \end{sideways} & \begin{sideways} Mirai \end{sideways} & \begin{sideways} Osiris \end{sideways}  & \begin{sideways} Loki \end{sideways} \\ \hline
			DLL Injection & & X & X & & X & &	\\ \hline
			Process hollowing & & & & & & X & X	\\ \hline
			Thread Execution Hijacking & & & & & & & 	\\ \hline
			Portable Executable Injection  & X & & & X & & &	\\ \hline
			Hook injection  & & & & & & &	\\ \hline
			APC Injection  & & & & & & &	\\ \hline
			Extra windows memory injection & & & & & & &	\\ \hline
		\end{tabular}
	\caption{Techniky ukrıvania èinnosti vyuívané súèasnım malvérom.}
\label{modulyVlastnosti}
\end{center}
\end{table}

\section{Process hollowing}
\noindent

Zvolenı spôsob ukrytia malvéru, ktorım sa bude táto práca zaobera je \textit{Process Hollowing, Hollow process}. Nasledujúca kapitola sa venuje spôsobu akım sa malvér môe ukry. Obsahuje potenciálne API funkcie, ktoré môe \textit{Process Hollowing} vyuíva na maskovanie svojho pôsobenia v systéme.

\subsection{Princíp}
\noindent
\begin{figure}[!htbp]
	\centering
	\includegraphics[width=11cm]{img/Diagram.jpg}
	\caption{ Ukáka zmien adresného priestoru poèas Hollowingu.}
	\label{vzhladobr}
\end{figure}
Princíp ukrytia malvéru akı vyuíva \textit{Process Hollowing} je podobnı spôsobu ukrytia malvéru, ktorı vyuíva \textit{DLL Injection}. Princím spoèíva v ukrytí malvéru do existujúceho beiaceho procesu, ktorı je v systéme Windows èasto vyuívanı a spustenie malvéru z tohto procesu by spôsobovalo najmenšie podozrenie. Takımto demonštratívnym procesom môe by \textit{svchost.exe}, ktorı je v systéme Windows èasto vyuívanı. \textit{Process Hollowing} pozastaví beiace vlákno procesu \textit{svchost.exe} a následne vytvorí vlákno, ktoré alokuje dostatoènú ve¾kú práznu virtuálnu pamä pre malvér v procese. Po alokovaní virtuálneho adresného priestoru v pamäti procesu do alokovanej èasti nakopíruje škodlivı kód a následne nastaví kedy sa danı škodlivı kód má spusti. Malvér sa môe v tomto prípade spusti po spustení pozastaveného vlákna alebo pri volaní nejakej konkrétnej funkcie. Po nastavení spúšaèa malvéru sa \textit{Process Hollowing} spustí pozastavené vlákno. Malvér môe pri následnom volaní funkcie, ktorá bola nastavená ako spúšaè škodlivého kódu spusti svoju èinnos pod legitimnım procesom.  

\subsection{Vyuívané API funkcie}
\textit{Process Hollowing} vyuíva na svoje fungovanie rôzne API funkcie a ich volania. Nasledujúce nami vybrané API funkcie, môe \textit{Process Hollowing} najpravdepodobnejšie vyuíva na svoje fungovanie k ukrytiu škodlivého kódu do nejakého beiaceho procesu. 
\begin{itemize}
\item
\textbf{CreateThread}
\\
Vytvorí vlákno na vykonanie procesu vo virtuálnom adresovom priestore volajúceho procesu.
\item
\textbf{CreateRemoteThread}
\\
Vytvorí vlákno, ktoré beí vo virtuálnom adresovom priestore iného procesu.
\item
\textbf{CreateRemoteThreadEx}
\\
Funkcia vytvára vlákno, ktoré sa spúša vo virtuálnom adresovom priestore iného procesu a prípadne špecifikujte rozšírené atribúty. Napríklad nekoneènos skupiny procesorov.
\item
\textbf{ResumeThread}
\\
Spúša pozastavené vlákno.
\item
\textbf{SuspendThread}
\\
Pozastaví zadané vlákno.
\item
\textbf{SwitchToThread}
\\
Spôsobí, e volajúce vlákno poskytne vykonanie inému vláknu, ktoré je pripravené na spustenie v aktuálnom procesore. Operaènı systém vyberie ïalšie vlákno, ktoré sa má vykona.
\item
\textbf{CreateProcessA}
\\
Vytvorí novı proces a jeho primárne vlákno. Novı proces beí v bezpeènostnom kontexte volajúceho procesu.
\item
\textbf{CreateProcessW}
\\
Vytvorí novı proces a jeho primárne vlákno. Novı proces beí v bezpeènostnom kontexte volajúceho procesu.
\item
\textbf{VirtuallAlloc}
\\
Rezervuje, potvrdzuje alebo mení stav oblasti stránok vo virtuálnom adresovom priestore volaného procesu. Pamä pridelená touto funkciou sa automaticky inicializuje na nulu.
\item
\textbf{VirtualAllocEx}
\\
Vyhradzuje, potvrdzuje alebo mení stav oblasti pamäte v rámci virtuálneho adresového priestoru špecifikovaného procesu. Funkcia inicializuje pamä, ktorú nastaví na nulu.
\item
\textbf{VirtuallAlloc2}
\\
Vyhradzuje, potvrdzuje alebo mení stav oblasti pamäte v rámci virtuálneho adresového priestoru špecifikovaného procesu. Funkcia inicializuje pamä, ktorú nastaví na nulu.
\item
\textbf{WriteProcessMemory}
\\
Zapisuje údaje do oblasti pamäte v zadanom procese. Celá oblas, do ktorej sa má zapísa, musí by prístupná inak operácia zlyhá.
\item
\textbf{ReadProcessMemory}
\\
Èíta udaje z pamäte v zadanom procese.
\item
\textbf{CopyMemory}
\\
Kopíruje pamä do vyhradenej alokovanej pamäti.
\item
\textbf{SetThreadContext}
\\
Nastavuje kontext pre aktuálne vlákno.
\item
\textbf{ExitThread}
\\
Ukonèí aktuálne vykonávané vlákno.
\item
\textbf{NtUnmapViewOfSection}
\\
Odmapuje pamä vybraného beiaceho procesu.
\\
\end{itemize}
\section{Existujúce riešenia na detekciu}
\noindent
Doposia¾ známe existujúce riešenia na detekciu techniky \textit{Process Hollowing} vyuívanej niektorımi malvérmy, sú urèené na forenznú analızu. Táto analıza prebieha u po infikovaní zariadenia malvérom a zistením, e sa škodlivı kód u v zariadení nachádza. Tieto riešenia neobsahujú spôsoby detekcie škodlivého kódu, ktoré by mohli odchyti malvér u pri infikovaní ¾ubovo¾ného zariadenia. 
\\

https://github.com/m0n0ph1/Process-Hollowing

https://github.com/idan1288/PHDetection

https://www.andreafortuna.org/2017/10/09/understanding-process-hollowing/

https://cysinfo.com/detecting-deceptive-hollowing-techniques/

https://www.microsoft.com/security/blog/2017/07/12/detecting-stealthier-cross-process-injection-techniques-with-windows-defender-atp-process-hollowing-and-atom-bombing/
\subsection{PHDetection}

\textit{PHDetection} h¾adá moduly, od ktorıch závisí pôvodnı .exe program. \textit{PHDetection} kontroluje èi sú moduly naèítané do procesnej pamäte programu. Ak nájde moduly, na ktorıch závisí dotyènı program ale nenájde ich v pamäti procesu, èo naznaèuje, e proces je prázny \textit{PHDetection} detekuje, e sa jedná o Process Hollowing. Pôvodné moduly boli nahradené touto metodóu za iné ktoré obsahujú škodlivı kód. Existuje nieko¾ko súborov, ktoré nezávisia od mnohıch modulov v IAT. Program analyzovuje aj tabu¾ku importu oneskoreného naèítania volania modulov. Program bol implementovanı v jazyku C++. Program sa spúša spustením súboru pod¾a verzie systému Windows \cite{phdetection}

V kadom riešení popis, akım spôsobom danı nástroj funguje, ako sa pouíva, v èom bol implementovanı + link na nástroj do literatúry.
\subsection{HollowFind}

Hollowfind je plugin pre program Volatility na detekciu rôznych typov techník \textit{Process Hollowing} pouívanıch vo vo¾nej prírode na obídenie, zamenenie a odklonenie techník forenznej analızy. Plugin detekuje takéto útoky zistením nezrovnalostí vo VAD a PEB, tie rozoberie adresu vstupného bodu, aby zistil akéko¾vek pokusy o presmerovanie, a tie nahlási akéko¾vek podozrivé pamäové oblasti, ktoré by mali pomôc pri detekcii akéhoko¾vek škodlivého kódu. Program bol napísanı v jazyku Phyton. Plugin sa spúšta v Programe Volatility po nainštalovaní.  \cite{hollowfind}

\section{Algoritmus na detekciu}
\noindent
\begin{figure}[!htbp]
	\centering
	\includegraphics[width=11cm]{img/Automat.jpg}
	\caption{Koneènı stavovı automat.}
	\label{Automat}
\end{figure}

Navrhnutı algoritmus na detegciu malvéru vyuívajúceho na svoje ukrytie v systéme \textit{Process Hollowing}, tvorí 5 prechodnıch stavov. Cez tieto sa algoritmus dostáva vïaka vybranım Windows API funkciám. Tieto funkcie umoòujú sledova volania jednotlivıch procesov, kde by mohol ukry malvér svoju èinnos. Jednotlivé API tak môeme rozdeli do 5 skupín.
\begin{itemize}
\item
\textbf{WAPI1}
Sú API funkcie, ktoré umoòujú vytvára nové vlákna procesov alebo získa prístupy do u existujúcich vlákien. 
\item
\textbf{WAPI2}
Predstavujú API primátrne urèené na odmapovanie pamäte existujúceho procesu.
\item
\textbf{WAPI3}
Predstavujú API, ktoré slúia na alokáciu pamäte pre dané vlákno alebo rozširujú virtuálnu pamä existujúceho procesu. 
\item
\textbf{WAPI4}
Tieto funkcie umoòujú manipulova s pamäou. Ako je kopírovanie pamäte, zapisovanie do pamäte atï..
\item
\textbf{WAPI5}
Tieto API funkcie nastavujú kontext daného vlákna a umoòujú nastavi \textit{Instruction Pointer}, ktorı pri volaní spustí aj funkcionalitu malvéru.  
\item
\textbf{WAPI6}
Poslednou skupinou sú API, ktoré spúšajú pozastavené vlákno alebo ukonèi funkcionalitu aktuálneho vlákna.
\end{itemize}

Algoritmus na detegovanie funguje na jednoduchom princípe. Podozrivı proces získa prístup do beiaceho vlákna legitímneho procesu. Vo vlákne daného procesu malvér alokuje virtuálnu pamä èím následne umoní do tejto pamäte zapísa svoj škodlivı kód. Poèas tıchto vıkonov operácií malvér volá jednotlivé API. Pri správnom odhade postupnosti volanıch API, je algoritmus schopnı vyhodnoti v reálnom èase èi v zariadení existuje hrozba v podobe malvéru a informova o tom uivate¾a.

\section{Implementácia}
Struènı úvod do implementácie, programovací jazyk, vıvojové prostredie + jednoduchı diagram fungovania celého systému.\\
\\
Pre implementáciu riešenia sme zvolili programovanı jazyk C++, pretoe primárnym testovavím prostredím budú najèastejšie pouívané systémy Windows. Na simuláciu testovanie prostredia pouijeme \textbf{Virtual Box} v ktorom budeme simulova bené pouívanie systému.
Zvolené vıvojové prostredie je \textbf{Visual Studio 2019}, ktoré nám umoòuje pracova s najnovšími verziami systému a aj u¾ahèi jednuduchšiu implementáciu algoritmu.

\begin{figure}[!htbp]
	\centering
	\includegraphics[width=12cm]{img/UML2.jpg}
	\caption{Moduly aplikácie}
	\label{UMLDiagram}
\end{figure}

Práca sa zaoberá návrhom a implementáciou spôsobu detegovania malvéru, ktorı na ukrytie svojej èinnosti v PC pouíva \textit{Process Hollowing}. Teda ukrıva svojú èinnos za iné bené programy, ktoré nie sú podozrivé. Aplikácia urèená na detegovanie takéhoto spôsobu ukrıvania malvéru bude bea v reálnom èase, teda je schopná detegova malvér poèas jeho behu. Vstupné dáta do tejto aplikácie budú predstavova volané API funkcie škodlivım softvérom a z tıchto API funkcií bude aplikácia vyhodnocova a poskytova vısledky èi v systéme operuje alebo neoperuje malvér. Aplikácia bude pozostáva z nasledujúcich èastí. Mutex, ktorı bude zabezpeèova plynulos a bezpeènos programu. Modul na injectovanie DLL, ktorı bude vklada DLL kninicu na odchytávanie volanıch API. Modul na vyhodnocovanie prítomnosti mavéru, ktorı sa skladá z viacerıch èastí. Modulu na naèítanie najnovších záznamov z DLL kninice. Koneèného stavového automatu reprezentovaného Maticou, oproti ktorej bude aplikácia porovnáva prechody medzi jednotlivımi stavmi pod¾a volanıch API. Archiváciou, ktorá zabezpeèí archiváciu dát po preèítaní najnovších záznamov z DLL kninice.  
\subsection{Algoritmus}

\begin{figure}[!htbp]
	\centering
	\includegraphics[width=9cm]{img/UML.jpg}
	\caption{UML diagram vyvıjaného algoritmu.}
	\label{UMLDiagram}
\end{figure}
\noindent
\\
Aplikácia na zaèiatku inicializuje mutex, ktorı slúi na bezpeèné zapisovanie a èítanie záznamov zo súboru. Následne aplikácia spustí modul na zber na dát, ktorı monitoruje aké API sa volajú v systéme Windows. Pre jednoduchšie monitorovanie vyuívame vo¾ne dostupnú aplikáciu \textit{Detours}. Aplikácia si nastaví poèiatoènú hodnutu prechodného stavu, ktorı slúi na vyhodnocovanie prítomnosti malvéru. Po nastavení všetkıch poèiatoènıch hodnôt aplikácia prejde na samotnú detegciu malvéru. Vlákno sa uspí na stanovenú dobu a po nastavení mutexu zaèína aplikácia samotnı proces detegovania. Aplikácia si naèíta najnovšie záznami z modulu na zber dát. Zo záznamu aplikácia vyberie volanú API funkciu a zisuje èi k danej API existuje hodnota v matici koneèného automatu. Ak áno, aplikácia zisuje aktuálny prechodnı stav a následne aj pomocou koneèného stavového automatu novú hodnotu do ktorej sa prechodnı stav následne zmení. Po vykonaní zmeny nastane kontrola na existenciu ïalších záznamov v súbore ak súbor obsahuje ïalšie záznami, naèíta si ïalší záznam a proces sa opakuje. Ak u aplikácia naèítala všetky záznami spraví sa archivácia záznamov a aplikácia vyhodnocuje prechodnı stav koneèného stavového automatu. Ak prechodnı stav nieje v koneènom stave mutex sa uvo¾ní a aplikácia èaká ïalšie záznami z modulu na zber dát a cyklus sa opakuje. Keï sa prechodnı stav dostane do konecného stavu aplikácia oznámi existenciu malvéru a ukonèí sa.  
\subsection{Modul na zber dát}
\noindent

Modul na zber dát predstavuje DLL kninicu (\textbf{Hook.dll}) vyuívanú na vloenie do vybraného procesu, cez ktorú sa následne odchytávajú vybrané API funkcie zapísaním do textového súboru. Modul sa skladá z dvoch èastí. Prvá èas predstavuje definície vybranıch API funkcií ako môeme vydie na obrázku, ku ktorım je následne definované aj ich volanie. Okrem volania konkrétnej API funkcie aj do pripraveného textového súboru zapíše èas a volanú API funkciu vo \textbf{writeFunctionToFile}, ktoré sú následne pouité v aplikácii na detegovanie malvéru v beiacom procese. 

\begin{lstlisting}[caption=Implementácia funkcie writeFunctionToFile.,label={vypis1}]
void writeFunctionToFile(std::string originalFunkcion) 
{
	DWORD ret = WaitForSingleObject(hMutex, INFINITE);
	
	if (ret == WAIT_OBJECT_0)
	{
		time_t now = time(NULL);
		tm* ltm = localtime(&now);
		std::ofstream myFile("api_data.txt", std::ofstream::app | std::ofstream::out);
		
		if (myFile.is_open())
		{
			myFile << ltm->tm_hour << ":" << ltm->tm_min << ":" << ltm->tm_sec << ";" + originalFunkcion << endl;
			myFile.close();
		}
		
		ReleaseMutex(hMutex);
	}
}
\end{lstlisting}
Druhá èas aplikácie u slúi len na nahradenie pôvodnej volanej API funkcie, modifikovanou tou istou funkciou, ktorá je rozšírenia o zapisovanie volanej API do súboru. Pôvodnú funkciu \textit{SetThreadContext} urèenú na nastavenie \textit{Instriction Pointer} v tomto module nahradíme funkciou \textit{HookSetThreadContext}, ktorá okrem volania pôvodnej funkcie volá aj funkciu \textbf{writeFunctionToFile} na zapísanie API funkcie do predpripraveného súboru.
\begin{lstlisting}[caption=Definícia API volania SetThreadContext.,label={vypiS3}]
static BOOL(__stdcall *RealSetThreadContext)(HANDLE, const CONTEXT*) = SetThreadContext;

BOOL WINAPI HookSetThreadContext(HANDLE hThread, const CONTEXT* lpContext)
{
	writeFunctionToFile("SetThreadContext");
	return RealSetThreadContext(hThread, lpContext);
}
\end{lstlisting}

\begin{lstlisting}[caption=Nahradenie pôvodnej funkcie SetThreadContext.,label={vypiS4}]
switch (ul_reason_for_call)
{
	case DLL_PROCESS_ATTACH:
	{
		DetourAttach(&(PVOID&)RealSetThreadContext, HookSetThreadContext);
		DetourTransactionCommit();
		break;
	}
	case DLL_PROCESS_DETACH:
	{
		DetourDetach(&(PVOID&)RealSetThreadContext, HookSetThreadContext);
		DetourTransactionCommit();
		break;
	}
}
\end{lstlisting}

\subsection{Detours}
\textit{Detours} je softvér urèenı na monitorovanie a inštruovanie API volaní v systéme Windows. Tento softvér podporuje rovnako 32 tak aj 64 bitovú verziu Windowsu. \textit{Detours} u¾ahèuje prácu vıvojárom, ktorı pracujú s rozhraním API volaní. Je k dispozícii na základe \textit{Open source} licencie a je vo¾ne dostupnı pre komunitu.

\subsection{Mutex}
Mutex je synchronizaènı objekt, ktorı slúi na signalizáciu pouívania nejakého objektu v procesnom vlákne. Mutex slúi na koordináciu viacerıch aplikácií (dvoch vlákien), ktoré vyadujú prístup k rovnakému objektu súèastne. Napríklad aby sa zabránilo zápisu dvoch vlákien súèastne do zdie¾aného objektu alebo pamäti. Take kadá aplikácia alebo vlákno èaká na uvo¾nonenie mutexu, ktoré signalizuje, e daná pamä nieje vyuívaná a môe sa do nej bezpeène zapisova bez toho aby došlo zápisu dvoch aplikácii súèastne. V tejto aplikácii mutex slúi na zabránenie zapisovaniu záznamov do súboru modulom na zber dát a èítaním záznamov z toho istého súboru detegènou aplikáciou súèastne.
\begin{lstlisting}[caption=Inicializácia mutexu.,label={vypiS5}]
HANDLE mutexOnThreadSafe;
mutexOnThreadSafe = CreateMutex(NULL, FALSE, TEXT("MutexOnThreadSafe"));

\end{lstlisting}

\subsection{Koneènı stavovı automat}

Koneènı automat je teoretickı vıpoètovı model pouívanı v informatike na štúdium rôznych formálych jazykoch. Popisuje ve¾mi jednoduchı poèítaè, ktorı môe by v jednom z nieko¾kıch stavov, medzi ktorımi prechádza na základe symbolov, ktoré èíta zo vstupu. Mnoina stavov je koneèná , koneènı automat nemá iadnu ïalšiu pamä, okrem informácie o aktuálnom stave. V informatike sa rozlišuje okrem základného deterministického èi nedeterministického automatu tie Mealyho a Moorov automat.

Koneènı automat je definovanı ako usporiadaná pätica (S, $\Sigma$ , $\sigma$, s, F) kde:\\
S je koneèná neprázdna mnoina stavov. \\
$\Sigma$ je koneèná neprázdna mnoina vstupnıch symbolov, nazıvaná abeceda.\\
$\sigma$ je prechodová funkcia respektíve prechodová tabu¾ka popisujúca prechod medzi jednotlivımi stavmi.\\
s je poèatoèná stav patriaci do mnoiny stavov S.\\
F je mnoina finálych akceptujúcich stavov.\\

Na zaèiatku sa automat nachádza v definovanom poèiatoènom stave. Ïalej v kadom kroku preèíta jeden symbol zo vstupu a prejde do stavu, ktorı je danı hodnotou, ktorá v prechodovej tabu¾ke zodpovedá aktuálnemu stavu a preèítanému symbolu. Potom pokraèuje èítaním ïalšieho symbolu zo vstupu, ïalším prechodom pod¾a prechodovej tabu¾ky atï.

Pod¾a toho, èi automat skonèí po preèítaní vstupe v stave, ktorı patrí do mnoiny prijímajúcich stavov, platí, e automat buï danı vstup prijal, alebo neprijal. Mnoina všetkıch reazcov, ktoré danı automat príjme, tvorí regulárny jazyk.

V našom prípade abecedu tvorí mnoina nami vybranıch API windows funkcií, ktoré by potenciálne mal najèastejšie vyuíva malvér vyuívajúci techniku \textit{Process Hollowing} na ukrytie svojej èinnosti. 

\subsection{Matica koneèného stavového automatu}
Matica reprezentuje prechody medzi jednotlivımi stavmi koneèného stavového automatu. tieto prechody sú definované ako volania vybranıch API, ktoré posúvajú automat cez jednotlivé stavy pod¾a toho v akom stave je aktuálne automat a do akého nového stavu sa automat dostane. Koneèná mnoina stavov je reprezentovaná stavmi {"štart","vytvorenie vlákna", "alokácia pamäte", "kopírovanie malvéru", "nastavenie IP", "spustenie vlákna" }. Poèiatoènı stav automatu je \textbf{štart} a koneènı stav je \textbf{spustenie vlákna}, ktorı oznamuje existenciu malvéru v zariadení.

\begin{table}[!htbp]
	\begin{center}
		\begin{tabular}{p{5cm}|c|c|c|c|c|c|c}
			& \multicolumn{7}{c}%
			{\textbf{Prechodové stavy}}\\ \hline
			\textbf{Volané API funkcie} &\begin{sideways} Štart \end{sideways} &\begin{sideways} Vytvorenie procesu/ Získanie prístupu do procesu \end{sideways} &\begin{sideways} Odmapovanie pamäte existujúceho procesu \end{sideways} &\begin{sideways} Alokácia virtuálnej pamäte \end{sideways} & \begin{sideways} Kopírovanie malvéru do alokovanej pamäte \end{sideways} & \begin{sideways} Nastavenie IP na spustenie malvéru \end{sideways} & \begin{sideways} Spustenie vlákna/ Spustenie pozastaveného procesu \end{sideways}  \\ \hline
			Skratky stavov & S0 & S1 & S2 & S3 & S4 & S5 & S6 \\ \hline
			CreateThread & S1 & S1 & S1 & S1 & S1 & S1 & S1 \\ \hline
			CreateRemoteThread & S1 & S1 & S1 & S1 & S1 & S1 & S1 \\ \hline
			CreateRemoteThreadEx & S1 & S1 & S1 & S1 & S1 & S1 & S1 \\ \hline
			CreateProcessA & S1 & S1 & S1 & S1 & S1 & S1 & S1 \\ \hline
			CreateProcessW & S1 & S1 & S1 & S1 & S1 & S1 & S1 \\ \hline
			SwitchToThread & S1 & S1 & S1 & S1 & S1 & S1 & S1 \\ \hline
			OpenThread & S1 & S1 & S1 & S1 & S1 & S1 & S1 \\ \hline
			SuspendThread & S1 & S1 & S1 & S1 & S1 & S1 & S1 \\ \hline
			NtUnmapViewOfSection & S0 & S2 & S2 & S3 & S4 & S5 & S6 \\ \hline
			VirtualAlloc & S0 & S1 & S3 & S3 & S4 & S5 & S6 \\ \hline
			VirtualAllocEx & S0 & S1 & S3 & S3 & S4 & S5 & S6 \\ \hline
			CopyMemory & S0 & S1 & S2 & S4 & S4 & S5 & S6 \\ \hline
			WriteProcessMemory & S0 & S1 & S2 & S4 & S4 & S5 & S6 \\ \hline
			ResumeThread & S0 & S1 & S2 & S3 & S4 & S6 & S6 \\ \hline
			ExitThread & S0 & S1 & S2 & S3 & S4 & S6 & S6 \\ \hline
			SetThreadPriority & S0 & S1 & S2 & S3 & S5 & S5 & S6 \\ \hline
			
		\end{tabular}
		\caption{Matica prechodov medzi stavmi pri volaniach API.}
		\label{maticaPrechodov}
	\end{center}
\end{table}

\section{Vısledky}
Struènı úvod do testovania nami vytvoreného riešenia/riešení. Zoznam experimentov.
Našu aplikáciu budeme testova vo \textit{Virtual Boxe}, na systéme Windows 10. Aplikáciu budeme testova na reálych vzorkách malvéru, ktoré vyuívajú \textit{Process Hollowing} na ukrytie svojej èinnosti. 
\subsection{Experiment A}
Detailnı popis experimentu, vısledky, úspešnos, graf, ko¾ko trval èas detegovania od spustenia experimentu a pod. To navrhneme pod¾a vısledkov implementácie.
\subsection{Experiment B}
\subsection{Porovnanie s existujúcimi riešeniami}
Ak to bude moné. Ak nie spomenú e existujúce riešenia vyuívajú metódy, ktoré neumoòujú priame porovnanie a pod.