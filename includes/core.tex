% !TeX spellcheck = sk_SK
\section{Malvér}
\noindent

\noindent Je to softvér, ktorého cie¾om je poškodi, zablokova, zmocni sa alebo odcudzi citlivé informácie uloené v poèítaèi. Cie¾om malvéru je získa informácie pre útoèníka a následné zneuitie tıchto informácií na rôzne druhy nelegálnej èinnosti za úèelom danej obeti uškodi alebo sa na nej finanène obohati. Malvér sa kedysi èlenil na rôzne kategórie ako napr. vírusy, \textit{backdoor}, \textit{spyware}, \textit{ramsomware} a pod.\cite{malvare} V súèasnosti u toto delenie nie je ve¾mi aktuálne, pretoe malvér v dnešnej dobe je u viacmenej kombináciou tıchto kategórií a vyuíva rôzne komponenty z jednotlivıch druhov škodlivého kódu. V nasledujúcej kapitole sa podrobnejšie zaoberáme rôznymi spôsobmi ukrıvania èinnosti a prítomnosti malvéru, ktoré môu by v súèasnosti vyuívané.
\vspace{20px}
\subsection{Techniky ukrıvania èinnosti}
\noindent 
Malvér vo všeobecnosti patrí ku škodlivému kódu. Preto je nutné jeho beiace procesy utaji. Ak chce by malvér úspešnı v získavaní údajov alebo finanènıch prostriedkov, musí by jeho beh ukrytı pred potenciálnym antivírusom, prípadne forenznım ininierom ktorı je schopnı ho odhali. Za tımto úèelom sa vyuívajú rôzne techniky na ukrytie malvéru buï v pamäti poèítaèa, rôznych shell skriptoch alebo dynamickıch kniniciach, aby boli èo najmenej detegovate¾né. \cite{malicious}

\begin{itemize}
	\item 
\textbf{DLL Injection / Reflective DLL Injection}
\noindent \\ \textit{DLL Injection} je technika, pri ktorej malvér zapíše cestu ku škodlivému DLL súboru do virtuálneho adresného priestoru legitímneho procesu a následne zabezpeèí aby danı proces túto dynamickú kninicu naèítal. Postup je nasledovnı: 

\begin{itemize}
	\item Škodlivı kód získa prístup ku legitímnemu procesu.
	\item V rámci legitímneho procesu alokuje priestor dostatoène ve¾kı na zapísanie cesty ku škodlivému DLL súboru.
	\item Malvér zapíše cestu ku škodlivému DLL súboru do virtuálneho adresného priestoru legitímneho procesu.
	\item Malvér na záver spustí vlákno v rámci legitímneho procesu, ktorého cie¾om je naèíta a spusti DLL súbor.
\end{itemize}

Hlavnım cie¾om \textit{DLL Injection} je škodlivı kód ukry do legitímneho procesu, kde je malvér ukrytı pred antivírovım softvérom, odkia¾ môe by následne spustenı \cite{endgame}.

\item 
\textbf{Proces Hollowing}
\noindent \\ Vyuíva podobné princípy ukrıvania škodlivého softvéru ako \textit{DLL Injection}. Cie¾om je ukry škodlivı kód do existujúce procesu, z ktorého sa následne bude vykonáva\cite{endgame}. Princíp je podobnı ako pri technike \textit{DLL Injection}:
\begin{itemize}
	\item Malvér spustí novı pozastavenı legitímny proces, do ktorého sa plánuje ukry.
	\item Škodlivı kód odmapuje pamä legitímneho procesu.
	\item Do virtuálneho adresného priestoru legitímneho procesu nakopíruje svoj škodlivı kód.
	\item Po dokonèení kopírovania nastaví novı vstupnı bod procesu a obnoví pozastavenı proces.
\end{itemize}

Ako môeme vidie, hlavnı rozdiel spoèíva najmä v odmapovaní existujúceho kódu. V prípade \textit{Process Hollowing} techniky bude v rámci neškodného procesu bea vıhradne iba škodlivı kód, na rozdiel od \textit{DLL injection}, kde v rámci jedného procesu sa nachádza škodlivı kód spolu s pôvodnım. Vısledkom môe by napr. spustenı benı proces \textit{svchost.exe}, ktorı ale v skutoènosti vykonáva škodlivú aktivitu.
\item 
\textbf{Thread Execution Hijacking }
\noindent \\
Pri tejto technike existujú urèité podobnosti s metódou \textit{Process Hollowing} a \textit{DLL injection} \cite{endgame}. Hlavnı princíp spoèíva v získaní prístupu u k existujúcemu vláknu legitímneho procesu, do ktorého chceme vloi škodlivı kód. Po získaní prístupu k vláknu, malvér dané vlákno pozastaví. Samotné injektovanie môe uskutoèni podobne ako pri \textit{DLL injection}, zapísaním cesty k DLL súboru a následnom naèítaní. Nevıhodou takéhoto spustenia pozastaveného programu je, e môe spôsobi pád systému v rámci systémového volania. Vıhodou ostáva, e technika nepotrebuje vytvori nové vlákno alebo proces a pouije u existujúce.

\item 
\textbf{Portable Executable Injection}
\noindent \\ 
Vıhodou tohoto spôsobu ukrytia malvéru je vyuitie nakopírovania celého PE súboru do existujúceho procesu \cite{endgame}. Ako vıhodu môeme taktie povavaova, e malvér nepotrebuje uloi iadne súbory na disk ale len priamo prekopíruje dáta PE súboru do legitímneho procesu. Hlavnou nevıhodou je, e sa zmení bázová adresa procesu a z toho dôvodu je nutné prepoèíta nové adresy v legitímnom procese tak, aby bolo zabezpeèené korektné správanie novo vloeného PE súboru.

\item 
\textbf{Hook injection}
\noindent \\
Hookovanie je všeobecne technika pouívaná na zachytávanie API volaní. \textit{Hook injection} vyuíva túto techniku na naèítanie škodlivého DLL, pri zachytení urèitej udalosti v konkrétnom vlákne \cite{endgame}. Pomocou prislušného API volania vieme nainštalova hook na špecifickú udalos v systéme (napr. stlaèenie klávesy), pre konkrétne vlákno v systéme. Taktie vieme špecifikova smerník na funkciu, ktorá sa má zavola ak daná udalos nastane. V tejto funkcii následne vieme urèi e sa má naèíta napr. škodlivé DLL. Môeme si všimnú e väšèina techník sa samotné naèítanie kódu vyuíva metódu naèítania škodlivého DLL do regulérneho procesu a hlavné rozdiely spoèívajú najmä v riešení ako donúni cudzí proces túto funkcionalitu vyvola.

\item 
\textbf{APC Injection}
\noindent \\
Škodlivı softvér môe vyuíva vıhody tzv. \textit{Asynchronous Procedure Calls} (APC), aby prinútil iné vlákno spusti svoj vlastnı kód \cite{endgame}. Túto funkcionalitu vie dosiahnú tak, e vloí dané vlákno do APC fronty. Kadé vlákno má vlastnú APC frontu, z ktorej vykonáva volania ak sa nachádza v pozastavenom stave a èaká na konkrétne udalosti. Podobne ako v predchádzajúcich prípadoch môe malvér do APC fronty vloi smerník na funkciu, v ktorej sa naèíta škodlivé DLL. Malvér zvyèajne h¾adá ¾ubovo¾né vlákno ktoré sa nachádza v špeciálnom stave, pri ktorom vykonáva postupne poloky v APC fronte. Takıchto vláken je väèšinou v systéme ve¾a.

\item 
\textbf{Extra windows memory injection}
\noindent \\
Tento spôsob schovávania softvéru sa spolieha na monos špecifikova dodatoènú pamä pri registrácii aplikaènıch okien v systéme. Pri registrácii nového okna aplikácie, softvér špecifikuje ïalšie bajty pamäte, ktoré rozšíria ve¾kos alokovanej pamäte pre spustenú aplikáciu \cite{endgame}, nazıvané aj \textit{Extra Windows Memory}(EWM). V tejto èasti ale nevzniká dostatok miesta na uloenie dát. Aby sa toto obmedzenie obišlo, škodlivı softvér zapíše kód do zdie¾anej pamäte a do EWM vloí ukazovate¾ na danú èast. Do tejto rozšírenej èasti zie¾anej pamäte ïalej softvér zapíše smerník na funkciu, ktorá obsahuje kód na naèítanie malvéru. Malvér môe nakoniec vyvola spustenie tohoto kódu pomocou konkrétnych Windows API volaní.
\end{itemize}
\vspace{20px}
\subsection{Súèasnı malvér}
\noindent \\
Táto kapitola obsahuje opis jednotlivıch vzoriek škodlivého kódu z roku 2019, ktoré boli detegované spoloènosami ako Avast a McAfee. Tieto vzorky sú najèastejšie vyuívané v oblasti Európy. Kapitola obsahuje bliší opis jednotlivıch vzoriek, ich vyuitie, pouité spôsoby útokov a ukrytie malvéru v systéme.

\begin{itemize}
\item
\textbf{Sodinokibi}
\noindent \\
Tento malvér bol detekovanı v období okolo apríla 2019. Patrí do rodiny ransomvéru, ktorıch cie¾om je zašifrova dáta v zariadení a následne za dešifrovanie pıta peniaze \cite{sinobiki} (väèšinou v podobe kryptomeny). Názov bol objavenı v heši, ktorı obsahoval názov \textit{Sodinokibi.exe}. Vírus sa šíri sám zmeuívaním zranite¾nosti v serveroch, ktoré pouívajú \textit{Oracle WebLogic}. Kód je navrhnutı tak, aby rıchlo vykonával šifrovanie špecifickıch súborov, definovanıch v konfigurácii ransomvéru. Prvou akciou škodlivého kódu je naèíta všetky externé funkcie potrebné poèas behu programu. Technika vyuívaná na ukrytie malvéru je \textit{Portable Executable Injection}. Analıza spoloènosti McAfee ukazuje podobnos s inım starším malvérom GandCrab.

\item
\textbf{Emotet}
\noindent \\
Emotet je malvér, ktorı sa primárne šíri pomocou rôznych spam emailov \cite{emotet2}. Na infikovanie zariadenia pouíva rôzne skripty, makrá v dokumetoch alebo linky. Emotet sa teda spolieha najmä na techniky sociálneho ininierstva. Prezentuje sa ako hodnovernı zástupca napr. banky, rôznych internetovıch obchodov, a pod. Emotet sa prvıkrát objavil v roku 2014 kedy vyuíval na infikovanie rôzne JavaScript súbory \cite{emotet}. V roku 2019 sa tento vírus objavil znova tentokrát u v pokroèilejšej verzii.  V novej verzii je Emotet u polymorfnım škodlivım kódom, èo mu umoòuje vyhnú sa klasickej detekcii. Emotet môe navyše generova falošné funkcionalitu, ak je spustenı vo virtuálnom prostredí èo zhoršuje jeho detekciu systéme.

\item
\textbf{ZeuS}
\noindent \\
Prvıkrát odhalenı v roku 2007 sa Zeus Trojan, ktorı sa èasto nazıva Zbot, stal jednım z najúspešnejších botnetov na svete a postihol milióny poèítaèov \cite{zeus2}. Taktie bolo vytvorernıch mnostvo variantov, ktoré boli zaloené na tomto malvéri. Po èase sa znovu objavil v pozmenenej podobe so zameraním na odchytávanie bankovıch operácii (odchytávanie prihlasovacích údajov do internet bankingu). Dosahuje to prostredníctvom monitorovania webovıch stránok a zaznamenávania klávesov. Keï malvér zistí, e sa pouívate¾ nachádza na webovej stránke banky, zaène zaznamenáva stlaèenia klávesov pouité na prihlásenie. Infekcia prebieha pomocou spamov. Keï uívate¾ klikne na odkaz v správe alebo stiahne obsah súboru, spolu s ním stiahne a spustí aj makro, ktoré po nainštalovaní umoòuje sledovanie zariadenia. 

\item
\textbf{Dridex}
\noindent \\
Dridex je známy trójsky kôò, ktorı sa špecializuje na kráde kreditnıch údajov v online bankovníctve. Tento typ škodlivého kódu sa objavil v roku 2014 a stále sa postupne vyvíja. Novı variant Dridex je schoplnı vyhnú sa detekcii tradiènımi antivírusovımi produktami. Tento malvér je v súèastnosti schopnı detekova pribline 25 a 30 percent aktuálnych antivírusovıch softvérov. \cite{dridex}

\item
\textbf{Mirai}
\noindent \\
\textit{Mirai} je samošírite¾nı typ škodlivého súboru na vytvorenie botnetu. Zdrojovı kód pre \textit{Mirai} bol autormi verejne sprístupnenı po úspešnom a dobre propagovanom útoku na webovú stránku Krebbs. Kód botnetu Mirai infikuje zariadania pripojené k internetu, ktoré vyuívajú telnet protokol (sieovı komunikaènı protokol zaloenı na TCP) na nájdenie tıch, ktoré stále pouívajú svoje predvolené uivate¾ské meno a heslo. Úèinnos málvéru \textit{Mirai} je spôsobená jeho schopnosou infikova desiatky tisíc tıchto nezabezpeèenıch zariadení a koordinova ich tak, aby zaèali útok DDoS proti vybranej obeti. \cite{mirai}

Mirai má dve hlavné zloky, samotnı vírus a C\&C server, ktorı ovláda kompromitované zariadenia (BOT) a posiela im pokyny na spustenie jedného z útokov proti jednej alebo viacerım obetiam. Proces skenera prebieha nepretrite na kadom infikovanom zariadení pomocou protokolu telnet (na porte TCP 23 alebo 2323)

C\&C predstavuje jednoduché rozhranie príkazového riadku, ktoré umoòuje útoèníkovi urèi algoritmus, IP adresu obete a trvanie útoku. C\&C tie èaká na to, aby jej existujúce BOT-y vrátili novoobjavené adresy zariadení, ktoré pouíva na ïalšie rozširovanie botnetu. Algoritmy sú konfigurovate¾né z C\&C, ale v predvolenom nastavení má \textit{Mirai} tendenciu náhodne rozde¾ova rôzne polia (ako sú èísla portov, poradové èísla, identifikátory atï.).

\item
\textbf{Osiris}
\noindent \\
Osiris je odvodenı od malvéru Kronos, ktorı sa zameriaval na bankovnívctvo. Podobne ako Kronos, je Osiris modernejšou verziou bankového trójskeho koòa \cite{osiris}. Táto verzia malvéru vyuíva na skrıvanie metódu \textit{process hollowing}. Umoòuje mu vydáva sa za legitímne procesy. Malvér sa šíri vydávaním sa za legitímny spustite¾nı súbor (útoky zaznamenné s malvérom Osiris boli dokumenty Microsoft Word). Vydávanie sa za inı oficiálny softvér znaène sauje identifikáciu malvéru a obmedzuje monosti na zastavenie útoku \cite{osiris2}. Malvér v dokumetoch Word obsahoval aj makrá, ktoré po spustení stiahli další škodlivı malvér, ktorı umouje zahåti zariadenia alebo sai detekcu

\item
\textbf{Loki}
\noindent \\
Loki je ïalšou variáciou staršieho malvéru Kronos. Rovnako ako Osiris, aj Loki vyuíva na svoje ukrytie metódu \textit{process hollowing}. Loki sa zameriava na krádee osobnıch údajov ako napr. prihlasovacie údaje a heslá. Od augusta 2018 a do súèasnosti sa Loki zameriava na firemné poštové schránky prostredníctvom phishingovıch a spamovıch e-mailov. Phishingové e-maily zahàòajú prílohu súboru s príponou .iso, ktorá sahuje a spúša škodlivı softvér.
\end{itemize}

Celkovı preh¾ad pouítıch techník v súèasnım vzorkách škodlivého kódu môeme vidie v tabu¾ke è.\ref{modulyVlastnosti}.
\begin{table}[!htbp]
	\begin{center}
		\begin{tabular}{p{4cm}|c|c|c|c|c|c|c|c}
			& \multicolumn{7}{c}%
			{\textbf{Technika ukrıvania}}\\ \hline
			\textbf{Názov malvéru} &\begin{sideways} Sodinokibi \end{sideways} &\begin{sideways} Emotet \end{sideways} &\begin{sideways} ZeuS \end{sideways} & \begin{sideways} Dridex \end{sideways} & \begin{sideways} Mirai \end{sideways} & \begin{sideways} Osiris \end{sideways}  & \begin{sideways} Loki \end{sideways} \\ \hline
			DLL Injection & & X & X & & X & &	\\ \hline
			Process hollowing & & & & & & X & X	\\ \hline
			Thread Execution Hijacking & & & & & & & 	\\ \hline
			Portable Executable Injection  & X & & & X & & &	\\ \hline
			Hook injection  & & & & & & &	\\ \hline
			APC Injection  & & & & & & &	\\ \hline
			Extra windows memory injection & & & & & & &	\\ \hline
		\end{tabular}
	\caption{Techniky ukrıvania èinnosti vyuívané súèasnım malvérom.}
\label{modulyVlastnosti}
\end{center}
\end{table}

\section{Process hollowing}
\noindent

Zvolenı spôsob ukrytia malvéru, ktorım sme sa v tejto práci zaoberali je \textit{process hollowing}. Nasledujúca kapitola sa venuje spôsobu akım sa malvér môe ukry pomocou spomínanej techniky. Taktie obsahuje potenciálne API funkcie pomocou ktorıch môe by technika \textit{process hollowing} implementovaná.

\begin{figure}[!htbp]
	\centering
	\includegraphics[width=12cm]{img/Diagram.jpg}
	\caption{ Ukáka zmien adresného priestoru poèas Hollowingu.}
	\label{vzhladobr}
\end{figure}

\subsection{Princíp}

Princíp ukrytia malvéru, ktorı vyuíva \textit{process hollowing} je do istej miery podobnı technike \textit{DLL Injection}. Hlavnı cie¾ metódy spoèíva v ukrytí škodlivého kódu do beného procesu, ktorı v systéme Windows spôsobuje èo najmenšie podozrenie \cite{hollowing}. Takımto procesom môe by napríklad \textit{svchost.exe}, ktorı je v systéme bene spustenı aj vo viacerıch inštanciách. \textit{Process hollowing} vytvorí pozastavenı proces \textit{svchost.exe} (prípadne získa prístup u k beiacemu procesu) a odmapuje jeho pamä. Po odmapovaní alokuje dostatok miesta vo virtuálnom adresnom priestore procesu. Následne, po alokácii nakopíruje škodlivı kód a nastaví novı vstupnı bod programu. Po ukonèení tıchto krokov obnoví pozastavenı proces. Vısledkom je navonok beiaci štandardnı proces \textit{svchost.exe}, ktorı ale vo vnútri vykonáva škodlivú èinnos. Schematické znázornenie priebehu tejto techniky môeme vidie na obrázku è.\ref{vzhladobr}.

\subsection{Vyuívané API funkcie}
\textit{Process hollowing} vyuíva na svoje fungovanie rôzne štandardné API volania. Nasledujúce nami vybrané API funkcie\cite{winapi}, môu by vyuité pri technike \textit{rocess hollowing}:
\begin{itemize}
\item
\textbf{CreateThread}
\\
Vytvorí nové vlákno vo virtuálnom adresnom priestore procesu, ktorı danú funkciu zavolal.
\item
\textbf{CreateRemoteThread}
\\
Vytvorí vlákno, ktoré beí vo virtuálnom adresovom priestore iného procesu.
\item
\textbf{CreateRemoteThreadEx}
\\
Funkcia vytvára vlákno, ktoré sa spúša vo virtuálnom adresovom priestore iného procesu a prípadne špecifikujte rozšírené atribúty, ako napr. nastavenie na ktorom procesore bude dané vlákno bea.
\\
\\
\item
\textbf{ResumeThread}
\\
Funkcia dekrementuje hodnotu, ktorá špecifikuje, ko¾krát bolo vlákno pozastavané. V prípade ak sa hodnota dostane na nulu, vlakno je obnovené. V opaènom prípade ostáva pozastavené. 
\item
\textbf{SuspendThread}
\\
Pozastavenie vykonávanie èinnosti špecifikovaného vlákna.
\item
\textbf{SwitchToThread}
\\
Spôsobuje prepnutie aktuálneho vlákna, na vlákno, ktoré je pripravené bea na procesore. Tento vıber vykonáva operaènı systém.
\item
\textbf{CreateProcessA}
Vytvorí novı proces a jeho hlavné vlákno. Novı proces beí s rovnakımi oprávneniami ako proces, ktorı danú funkciu zavolal.
\item
\textbf{VirtuallAlloc}
\\
Alokuje alebo mení oprávnenia stránok vo virtuálnom adresom priestore procesu, ktorı danú funkciu zavolal. Alokovaná pamä je automaticky inicializovaná na nulu.
\item
\textbf{VirtualAllocEx}
\\
Funguje rovnako ako \textit{VirtualAlloc}, s tım rozdielom, e alokuje pamä v rámci virtuálneho adresného priestoru iného procesu.
\item
\textbf{WriteProcessMemory}
\\
Zapisuje údaje do pamäti v zadanom procese. Celá oblas, do ktorej sa zapisuje, musí ma potrebné oprávnenia na zápis.
\item
\textbf{ReadProcessMemory}
\\
Èíta údaje z virtuálneho adresného priestoru špecifikovaného procesu.
\item
\textbf{SetThreadContext}
\\
Nastavuje kontext (t.j. obsah registrov) pre špecifikované vlákno.
\item
\textbf{ExitThread}
\\
Keï sa táto funkcia zavolá, všetky udalosti aktuálneho vlákna sa zrušia. Podobne všetky èakajúce vstupno-vıstupné udalosti iniciované vláknom sa zrušené a vlákno ukonèí svoju èinnos. 
\item
\textbf{NtUnmapViewOfSection}
\\
Odmapuje pamä vybraného procesu.
\\
\end{itemize}
\section{Existujúce riešenia na detekciu}\label{existingsolutions}
\noindent
Doposia¾ známe existujúce riešenia na detekciu techniky \textit{process hollowing} vyuívanej niektorımi vzorkami škodlivého kódu, sú urèené na forenznú analızu. Táto analıza prebieha a po infikovaní zariadenia malvérom a zistením, e škodlivı kód sa u v zariadení nachádza. Riešenia spomínané v tejto kapitole sa teda nezameriavajú na detekciu techniky v reálnom èase. 

\subsection{PHDetection}

\textit{PHDetection} h¾adá moduly, od ktorıch závisí pôvodnı spustite¾nı program \cite{phdetection}. \textit{PHDetection} kontroluje èi sú dané moduly naèítané do pamäte programu. Ak nástroj nájde moduly, na ktorıch závisí dotyènı program (t.j. sú zapísané v IAT) ale nenájde ich v pamäti procesu, \textit{PHDetection} deteguje e sa jedná o \textit{process hollowing} a pôvodnı proces bol nahradenı inım. Existuje mnoho spustite¾nıch súborov, ktoré nezávisia od ve¾kého poètu modulov a kvôli tomu nástroj analyzuje aj tabu¾ku importov, v ktorej sa nachádzajú moduly, ktoré sa majú naèíta a poèas prvého pouitia. To znamená e DLL súbor sa naèíta do pamäte procesu a v momente, kedy sa zavolá prvá funkcia z tohoto modulu. \textit{PHDetection} teda postupne prechádza všetky beiace procesy a analyzuje naèítané moduly. V prípade ak danı modul nastavenı na neskoršie naèítanie a ešte sa nenachádza v pamäti, nástroj porovnáva èasové znaèky spustite¾ného súboru na disku a v pamäti. Program bol implementovanı v jazyku C++.

\subsection{HollowFind}

\textit{Hollowfind} je plugin pre nástroj \textit{Volatility} na detekciu rôznych typov techniky \textit{process hollowing} pouívanıch škodlivım kódom \cite{hollowfind}. Plugin sa zameriava taktie na rôzne formy obfuskácie danej techniky s cie¾om saenia forenznej analızy. Plugin deteguje metódu na základe porovnávania VAD a PEB tabuliek. VAD tabu¾ka je stromová štruktúra reprezentujúca jednotlivé stránky vo virtuálnom adresnom priestore a PEB tabu¾ka obsahuje rôzne informácie o konkrétnom procese. Príkladom môe by chıbajúca cesta k spustite¾nému súboru vo VAD tabu¾ke alebo rôzne bázové adresy procesu v PEB a VAD tabu¾ke.

\section{Algoritmus na detekciu}
\noindent
\begin{figure}[!htbp]
	\centering
	\includegraphics[width=11cm]{img/Automat.jpg}
	\caption{Koneènı stavovı automat.}
	\label{Automat}
\end{figure}

Navrhnutı algoritmus na detegciu malvéru vyuívajúceho na svoje ukrytie v systéme \textit{Process Hollowing}, tvorí 5 prechodnıch stavov. Cez tieto sa algoritmus dostáva vïaka vybranım Windows API funkciám. Tieto funkcie umoòujú sledova volania jednotlivıch procesov, kde by mohol ukry malvér svoju èinnos. Jednotlivé API tak môeme rozdeli do 5 skupín.
\begin{itemize}
\item
\textbf{WAPI1}
Sú API funkcie, ktoré umoòujú vytvára nové vlákna procesov alebo získa prístupy do u existujúcich vlákien. \\
CreateThread,
SuspendThread,
CreateProcessA.
\item
\textbf{WAPI2}
Predstavujú API primátrne urèené na odmapovanie pamäte existujúceho procesu. \\
NtUnmapViewOfSection.
\item
\textbf{WAPI3}
Predstavujú API, ktoré slúia na alokáciu pamäte pre dané vlákno alebo rozširujú virtuálnu pamä existujúceho procesu. \\
VirtualAlloc,
VirtualAllocEx.
\item
\textbf{WAPI4}
Tieto funkcie umoòujú manipulova s pamäou. Ako je kopírovanie pamäte, zapisovanie do pamäte atï.. \\
WriteProcessMemory,
CopyMemory.
\item
\textbf{WAPI5}
Tieto API funkcie nastavujú kontext daného vlákna a umoòujú nastavi \textit{Instruction Pointer}, ktorı pri volaní spustí aj funkcionalitu malvéru. \\
SetThreadContext 
\item
\textbf{WAPI6}
Poslednou skupinou sú API, ktoré spúšajú pozastavené vlákno alebo ukonèi funkcionalitu aktuálneho vlákna.\\
ResumeThread,
ExitThread.
\end{itemize}

Algoritmus na detegovanie funguje na jednoduchom princípe. Podozrivı proces získa prístup do beiaceho vlákna legitímneho procesu. Vo vlákne daného procesu malvér alokuje virtuálnu pamä èím následne umoní do tejto pamäte zapísa svoj škodlivı kód. Poèas tıchto vıkonov operácií malvér volá jednotlivé API. Pri správnom odhade postupnosti volanıch API, je algoritmus schopnı vyhodnoti v reálnom èase èi v zariadení existuje hrozba v podobe malvéru a informova o tom uivate¾a.

\subsection{Koneènı stavovı automat}

Koneènı automat je teoretickı vıpoètovı model pouívanı v informatike na štúdium rôznych formálych jazykoch. Popisuje ve¾mi jednoduchı poèítaè, ktorı môe by v jednom z nieko¾kıch stavov, medzi ktorımi prechádza na základe symbolov, ktoré èíta zo vstupu. Mnoina stavov je koneèná , koneènı automat nemá iadnu ïalšiu pamä, okrem informácie o aktuálnom stave. V informatike sa rozlišuje okrem základného deterministického èi nedeterministického automatu tie Mealyho a Moorov automat.

Koneènı automat je definovanı ako usporiadaná pätica (S, $\Sigma$ , $\sigma$, s, F) kde:\\
S je koneèná neprázdna mnoina stavov. \\
$\Sigma$ je koneèná neprázdna mnoina vstupnıch symbolov, nazıvaná abeceda.\\
$\sigma$ je prechodová funkcia respektíve prechodová tabu¾ka popisujúca prechod medzi jednotlivımi stavmi.\\
s je poèatoèná stav patriaci do mnoiny stavov S.\\
F je mnoina finálych akceptujúcich stavov.\\

Na zaèiatku sa automat nachádza v definovanom poèiatoènom stave. Ïalej v kadom kroku preèíta jeden symbol zo vstupu a prejde do stavu, ktorı je danı hodnotou, ktorá v prechodovej tabu¾ke zodpovedá aktuálnemu stavu a preèítanému symbolu. Potom pokraèuje èítaním ïalšieho symbolu zo vstupu, ïalším prechodom pod¾a prechodovej tabu¾ky atï.

Pod¾a toho, èi automat skonèí po preèítaní vstupe v stave, ktorı patrí do mnoiny prijímajúcich stavov, platí, e automat buï danı vstup prijal, alebo neprijal. Mnoina všetkıch reazcov, ktoré danı automat príjme, tvorí regulárny jazyk.

V našom prípade abecedu tvorí mnoina nami vybranıch API windows funkcií, ktoré by potenciálne mal najèastejšie vyuíva malvér vyuívajúci techniku \textit{Process Hollowing} na ukrytie svojej èinnosti. 

\subsection{Matica koneèného stavového automatu}
Matica reprezentuje prechody medzi jednotlivımi stavmi koneèného stavového automatu. tieto prechody sú definované ako volania vybranıch API, ktoré posúvajú automat cez jednotlivé stavy pod¾a toho v akom stave je aktuálne automat a do akého nového stavu sa automat dostane. Koneèná mnoina stavov je reprezentovaná stavmi {"štart","vytvorenie vlákna", "alokácia pamäte", "kopírovanie malvéru", "nastavenie IP", "spustenie vlákna" }. Poèiatoènı stav automatu je \textbf{štart} a koneènı stav je \textbf{spustenie vlákna}, ktorı oznamuje existenciu malvéru v zariadení.

\begin{table}[!htbp]
	\begin{center}
		\begin{tabular}{p{5cm}|c|c|c|c|c|c|c}
			& \multicolumn{7}{c}%
			{\textbf{Prechodové stavy}}\\ \hline
			\textbf{Volané API funkcie} &\begin{sideways} Štart \end{sideways} &\begin{sideways} Vytvorenie procesu/ Získanie prístupu do procesu \end{sideways} &\begin{sideways} Odmapovanie pamäte existujúceho procesu \end{sideways} &\begin{sideways} Alokácia virtuálnej pamäte \end{sideways} & \begin{sideways} Kopírovanie malvéru do alokovanej pamäte \end{sideways} & \begin{sideways} Nastavenie IP na spustenie malvéru \end{sideways} & \begin{sideways} Spustenie vlákna/ Spustenie pozastaveného procesu \end{sideways}  \\ \hline
			Skratky stavov & S0 & S1 & S2 & S3 & S4 & S5 & S6 \\ \hline
			CreateThread & S1 & S1 & S1 & S1 & S1 & S1 & S1 \\ \hline
			CreateRemoteThread & S1 & S1 & S1 & S1 & S1 & S1 & S1 \\ \hline
			CreateRemoteThreadEx & S1 & S1 & S1 & S1 & S1 & S1 & S1 \\ \hline
			CreateProcessA & S1 & S1 & S1 & S1 & S1 & S1 & S1 \\ \hline
			CreateProcessW & S1 & S1 & S1 & S1 & S1 & S1 & S1 \\ \hline
			SwitchToThread & S1 & S1 & S1 & S1 & S1 & S1 & S1 \\ \hline
			OpenThread & S1 & S1 & S1 & S1 & S1 & S1 & S1 \\ \hline
			SuspendThread & S1 & S1 & S1 & S1 & S1 & S1 & S1 \\ \hline
			NtUnmapViewOfSection & S0 & S2 & S2 & S3 & S4 & S5 & S6 \\ \hline
			VirtualAlloc & S0 & S1 & S3 & S3 & S4 & S5 & S6 \\ \hline
			VirtualAllocEx & S0 & S1 & S3 & S3 & S4 & S5 & S6 \\ \hline
			CopyMemory & S0 & S1 & S2 & S4 & S4 & S5 & S6 \\ \hline
			WriteProcessMemory & S0 & S1 & S2 & S4 & S4 & S5 & S6 \\ \hline
			ResumeThread & S0 & S1 & S2 & S3 & S4 & S6 & S6 \\ \hline
			ExitThread & S0 & S1 & S2 & S3 & S4 & S6 & S6 \\ \hline
			SetThreadPriority & S0 & S1 & S2 & S3 & S5 & S5 & S6 \\ \hline
			
		\end{tabular}
		\caption{Matica prechodov medzi stavmi pri volaniach API.}
		\label{maticaPrechodov}
	\end{center}
\end{table}

\section{Implementácia}\label{implementation}
Struènı úvod do implementácie, programovací jazyk, vıvojové prostredie + jednoduchı diagram fungovania celého systému.\\
\\
Pre implementáciu riešenia sme zvolili programovanı jazyk C++, pretoe primárnym testovavím prostredím budú najèastejšie pouívané systémy Windows. Na simuláciu testovanie prostredia pouijeme \textbf{Virtual Box} v ktorom budeme simulova bené pouívanie systému.
Zvolené vıvojové prostredie je \textbf{Visual Studio 2019}, ktoré nám umoòuje pracova s najnovšími verziami systému a aj u¾ahèi jednuduchšiu implementáciu algoritmu.

\begin{figure}[!htbp]
	\centering
	\includegraphics[width=12cm]{img/UML2.jpg}
	\caption{Moduly aplikácie}
	\label{UMLDiagram}
\end{figure}

Práca sa zaoberá návrhom a implementáciou spôsobu detegovania malvéru, ktorı na ukrytie svojej èinnosti v PC pouíva \textit{Process Hollowing}. Teda ukrıva svojú èinnos za iné bené programy, ktoré nie sú podozrivé. Aplikácia urèená na detegovanie takéhoto spôsobu ukrıvania malvéru bude bea v reálnom èase, teda je schopná detegova malvér poèas jeho behu. Vstupné dáta do tejto aplikácie budú predstavova volané API funkcie škodlivım softvérom a z tıchto API funkcií bude aplikácia vyhodnocova a poskytova vısledky èi v systéme operuje alebo neoperuje malvér. Aplikácia bude pozostáva z nasledujúcich èastí. Mutex, ktorı bude zabezpeèova plynulos a bezpeènos programu. Modul na injectovanie DLL, ktorı bude vklada DLL kninicu na odchytávanie volanıch API. Modul na vyhodnocovanie prítomnosti mavéru, ktorı sa skladá z viacerıch èastí. Modulu na naèítanie najnovších záznamov z DLL kninice. Koneèného stavového automatu reprezentovaného Maticou, oproti ktorej bude aplikácia porovnáva prechody medzi jednotlivımi stavmi pod¾a volanıch API. Archiváciou, ktorá zabezpeèí archiváciu dát po preèítaní najnovších záznamov z DLL kninice.  
\subsection{Algoritmus}

\begin{figure}[!htbp]
	\centering
	\includegraphics[width=9cm]{img/UML.jpg}
	\caption{UML diagram vyvıjaného algoritmu.}
	\label{UMLDiagram}
\end{figure}
\noindent
\\
Aplikácia na zaèiatku inicializuje mutex, ktorı slúi na bezpeèné zapisovanie a èítanie záznamov zo súboru. Následne aplikácia spustí modul na zber na dát, ktorı monitoruje aké API sa volajú v systéme Windows. Pre jednoduchšie monitorovanie vyuívame vo¾ne dostupnú aplikáciu \textit{Detours}. Aplikácia si nastaví poèiatoènú hodnutu prechodného stavu, ktorı slúi na vyhodnocovanie prítomnosti malvéru. Po nastavení všetkıch poèiatoènıch hodnôt aplikácia prejde na samotnú detegciu malvéru. Vlákno sa uspí na stanovenú dobu a po nastavení mutexu zaèína aplikácia samotnı proces detegovania. Aplikácia si naèíta najnovšie záznami z modulu na zber dát. Zo záznamu aplikácia vyberie volanú API funkciu a zisuje èi k danej API existuje hodnota v matici koneèného automatu. Ak áno, aplikácia zisuje aktuálny prechodnı stav a následne aj pomocou koneèného stavového automatu novú hodnotu do ktorej sa prechodnı stav následne zmení. Po vykonaní zmeny nastane kontrola na existenciu ïalších záznamov v súbore ak súbor obsahuje ïalšie záznami, naèíta si ïalší záznam a proces sa opakuje. Ak u aplikácia naèítala všetky záznami spraví sa archivácia záznamov a aplikácia vyhodnocuje prechodnı stav koneèného stavového automatu. Ak prechodnı stav nieje v koneènom stave mutex sa uvo¾ní a aplikácia èaká ïalšie záznami z modulu na zber dát a cyklus sa opakuje. Keï sa prechodnı stav dostane do konecného stavu aplikácia oznámi existenciu malvéru a ukonèí sa.  
\subsection{Modul na zber dát}
\noindent

Modul na zber dát predstavuje DLL kninicu (\textbf{Hook.dll}) vyuívanú na vloenie do vybraného procesu, cez ktorú sa následne odchytávajú vybrané API funkcie zapísaním do textového súboru. Modul sa skladá z dvoch èastí. Prvá èas predstavuje definície vybranıch API funkcií ako môeme vydie na obrázku, ku ktorım je následne definované aj ich volanie. Okrem volania konkrétnej API funkcie aj do pripraveného textového súboru zapíše èas a volanú API funkciu vo \textbf{writeFunctionToFile}, ktoré sú následne pouité v aplikácii na detegovanie malvéru v beiacom procese. 

\begin{lstlisting}[caption=Implementácia funkcie writeFunctionToFile.,label={vypis1}]
void writeFunctionToFile(std::string originalFunkcion) 
{
	DWORD ret = WaitForSingleObject(hMutex, INFINITE);
	
	if (ret == WAIT_OBJECT_0)
	{
		time_t now = time(NULL);
		tm* ltm = localtime(&now);
		std::ofstream myFile("api_data.txt", std::ofstream::app | std::ofstream::out);
		
		if (myFile.is_open())
		{
			myFile << ltm->tm_hour << ":" << ltm->tm_min << ":" << ltm->tm_sec << ";" + originalFunkcion << endl;
			myFile.close();
		}
		
		ReleaseMutex(hMutex);
	}
}
\end{lstlisting}
Druhá èas aplikácie u slúi len na nahradenie pôvodnej volanej API funkcie, modifikovanou tou istou funkciou, ktorá je rozšírenia o zapisovanie volanej API do súboru. Pôvodnú funkciu \textit{SetThreadContext} urèenú na nastavenie \textit{Instriction Pointer} v tomto module nahradíme funkciou \textit{HookSetThreadContext}, ktorá okrem volania pôvodnej funkcie volá aj funkciu \textbf{writeFunctionToFile} na zapísanie API funkcie do predpripraveného súboru.
\begin{lstlisting}[caption=Definícia API volania SetThreadContext.,label={vypiS3}]
static BOOL(__stdcall *RealSetThreadContext)(HANDLE, const CONTEXT*) = SetThreadContext;

BOOL WINAPI HookSetThreadContext(HANDLE hThread, const CONTEXT* lpContext)
{
	writeFunctionToFile("SetThreadContext");
	return RealSetThreadContext(hThread, lpContext);
}
\end{lstlisting}

\begin{lstlisting}[caption=Nahradenie pôvodnej funkcie SetThreadContext.,label={vypiS4}]
switch (ul_reason_for_call)
{
	case DLL_PROCESS_ATTACH:
	{
		DetourAttach(&(PVOID&)RealSetThreadContext, HookSetThreadContext);
		DetourTransactionCommit();
		break;
	}
	case DLL_PROCESS_DETACH:
	{
		DetourDetach(&(PVOID&)RealSetThreadContext, HookSetThreadContext);
		DetourTransactionCommit();
		break;
	}
}
\end{lstlisting}

\subsection{Detours}
\textit{Detours} je kninica urèená na monitorovanie a inštruovanie API volaní v systéme Windows. Táto kninica podporuje rovnako 32 tak aj 64 bitovú verziu Windowsu. \textit{Detours} u¾ahèuje prácu vıvojárom, ktorı pracujú s rozhraním API volaní. Je k dispozícii na základe \textit{Open source} licencie a je vo¾ne dostupnı pre komunitu.
Kninica sa aplikuje dynamicky za behu programu. Detours nahrádza pokyny cie¾ovej funkcie skokom na funkciu zadanú pouívate¾om. Kód cie¾ovej funkcie je modifikovanı v pamäti, nie na disku, èo umoòuje zachytávanie binárnych funkcií. \cite{detours} Po naèítaní do procesu môe kninica DLL obís akúko¾vek funkciu v procese, èi u v aplikácii alebo v systémovıch kniniciach, ako sú napríklad rozhrania Windows API.

\subsection{Mutex}
Mutex je synchronizaènı objekt, ktorı slúi na signalizáciu pouívania nejakého objektu v procesnom vlákne. Mutex slúi na koordináciu viacerıch aplikácií (dvoch vlákien), ktoré vyadujú prístup k rovnakému objektu súèastne. Napríklad aby sa zabránilo zápisu dvoch vlákien súèastne do zdie¾aného objektu alebo pamäti. Take kadá aplikácia alebo vlákno èaká na uvo¾nonenie mutexu, ktoré signalizuje, e daná pamä nieje vyuívaná a môe sa do nej bezpeène zapisova bez toho aby došlo zápisu dvoch aplikácii súèastne. V tejto aplikácii mutex slúi na zabránenie zapisovaniu záznamov do súboru modulom na zber dát a èítaním záznamov z toho istého súboru detegènou aplikáciou súèastne.
\begin{lstlisting}[caption=Inicializácia mutexu.,label={vypiS5}]
HANDLE mutexOnThreadSafe;
mutexOnThreadSafe = CreateMutex(NULL, FALSE, TEXT("MutexOnThreadSafe"));

\end{lstlisting}

\section{Vısledky}\label{results}
Struènı úvod do testovania nami vytvoreného riešenia/riešení. Zoznam experimentov.
Našu aplikáciu budeme testova vo \textit{Virtual Boxe}, na systéme Windows 10. Aplikáciu budeme testova na reálych vzorkách malvéru, ktoré vyuívajú \textit{Process Hollowing} na ukrytie svojej èinnosti. 
\subsection{Experiment A}
Detailnı popis experimentu, vısledky, úspešnos, graf, ko¾ko trval èas detegovania od spustenia experimentu a pod. To navrhneme pod¾a vısledkov implementácie.
\subsection{Experiment B}
\subsection{Porovnanie s existujúcimi riešeniami}
Ak to bude moné. Ak nie spomenú e existujúce riešenia vyuívajú metódy, ktoré neumoòujú priame porovnanie a pod.