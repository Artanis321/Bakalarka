% !TeX spellcheck = sk_SK
\section{Malvér}
\noindent

\noindent Je to softvér, ktorého cie¾om je poškodi, zablokova, zmocni sa alebo odcudzi citlivé informácie uloené v poèítaèi. Cie¾om malvéru je získa informácie pre útoèníka a následné zneuitie tıchto informácií na rôzne druhy nelegálnej èinnosti za úèelom danej obeti uškodi alebo sa na nej finanène obohati. Malvér sa kedysi èlenil na rôzne kategórie ako napr. vírusy, \textit{backdoor}, \textit{spyware}, \textit{ramsomware} a pod.\cite{malvare} V súèasnosti u toto delenie nie je ve¾mi aktuálne, pretoe malvér v dnešnej dobe je u viacmenej kombináciou tıchto kategórií a vyuíva rôzne komponenty z jednotlivıch druhov škodlivého kódu. V nasledujúcej kapitole sa podrobnejšie zaoberáme rôznymi spôsobmi ukrıvania èinnosti a prítomnosti malvéru, ktoré môu by v súèasnosti vyuívané.
\vspace{20px}
\subsection{Techniky ukrıvania èinnosti}
\noindent 
Malvér vo všeobecnosti patrí ku škodlivému kódu. Preto je nutné jeho beiace procesy utaji. Ak chce by malvér úspešnı v získavaní údajov alebo finanènıch prostriedkov, musí by jeho beh ukrytı pred potenciálnym antivírusom, prípadne forenznım ininierom ktorı je schopnı ho odhali. Za tımto úèelom sa vyuívajú rôzne techniky na ukrytie malvéru buï v pamäti poèítaèa, rôznych shell skriptoch alebo dynamickıch kniniciach, aby boli èo najmenej detegovate¾né. \cite{malicious}

\begin{itemize}
	\item 
\textbf{DLL Injection / Reflective DLL Injection}
\noindent \\ \textit{DLL Injection} je technika, pri ktorej malvér zapíše cestu ku škodlivému DLL súboru do virtuálneho adresného priestoru legitímneho procesu a následne zabezpeèí aby danı proces túto dynamickú kninicu naèítal. Postup je nasledovnı: 

\begin{itemize}
	\item Škodlivı kód získa prístup ku legitímnemu procesu.
	\item V rámci legitímneho procesu alokuje priestor dostatoène ve¾kı na zapísanie cesty ku škodlivému DLL súboru.
	\item Malvér zapíše cestu ku škodlivému DLL súboru do virtuálneho adresného priestoru legitímneho procesu.
	\item Malvér na záver spustí vlákno v rámci legitímneho procesu, ktorého cie¾om je naèíta a spusti DLL súbor.
\end{itemize}

Hlavnım cie¾om \textit{DLL Injection} je škodlivı kód ukry do legitímneho procesu, kde je malvér ukrytı pred antivírovım softvérom, odkia¾ môe by následne spustenı \cite{endgame}.

\item 
\textbf{Proces Hollowing}
\noindent \\ Vyuíva podobné princípy ukrıvania škodlivého softvéru ako \textit{DLL Injection}. Cie¾om je ukry škodlivı kód do existujúce procesu, z ktorého sa následne bude vykonáva\cite{endgame}. Princíp je podobnı ako pri technike \textit{DLL Injection}:
\begin{itemize}
	\item Malvér spustí novı pozastavenı legitímny proces, do ktorého sa plánuje ukry.
	\item Škodlivı kód odmapuje pamä legitímneho procesu.
	\item Do virtuálneho adresného priestoru legitímneho procesu nakopíruje svoj škodlivı kód.
	\item Po dokonèení kopírovania nastaví novı vstupnı bod procesu a obnoví pozastavenı proces.
\end{itemize}

Ako môeme vidie, hlavnı rozdiel spoèíva najmä v odmapovaní existujúceho kódu. V prípade \textit{Process Hollowing} techniky bude v rámci neškodného procesu bea vıhradne iba škodlivı kód, na rozdiel od \textit{DLL injection}, kde v rámci jedného procesu sa nachádza škodlivı kód spolu s pôvodnım. Vısledkom môe by napr. spustenı benı proces \textit{svchost.exe}, ktorı ale v skutoènosti vykonáva škodlivú aktivitu.
\item 
\textbf{Thread Execution Hijacking }
\noindent \\
Pri tejto technike existujú urèité podobnosti s metódou \textit{Process Hollowing} a \textit{DLL injection} \cite{endgame}. Hlavnı princíp spoèíva v získaní prístupu u k existujúcemu vláknu legitímneho procesu, do ktorého chceme vloi škodlivı kód. Po získaní prístupu k vláknu, malvér dané vlákno pozastaví. Samotné injektovanie môe uskutoèni podobne ako pri \textit{DLL injection}, zapísaním cesty k DLL súboru a následnom naèítaní. Nevıhodou takéhoto spustenia pozastaveného programu je, e môe spôsobi pád systému v rámci systémového volania. Vıhodou ostáva, e technika nepotrebuje vytvori nové vlákno alebo proces a pouije u existujúce.

\item 
\textbf{Portable Executable Injection}
\noindent \\ 
Vıhodou tohoto spôsobu ukrytia malvéru je vyuitie nakopírovania celého PE súboru do existujúceho procesu \cite{endgame}. Ako vıhodu môeme taktie povavaova, e malvér nepotrebuje uloi iadne súbory na disk ale len priamo prekopíruje dáta PE súboru do legitímneho procesu. Hlavnou nevıhodou je, e sa zmení bázová adresa procesu a z toho dôvodu je nutné prepoèíta nové adresy v legitímnom procese tak, aby bolo zabezpeèené korektné správanie novo vloeného PE súboru.

\item 
\textbf{Hook injection}
\noindent \\
Hookovanie je všeobecne technika pouívaná na zachytávanie API volaní. \textit{Hook injection} vyuíva túto techniku na naèítanie škodlivého DLL, pri zachytení urèitej udalosti v konkrétnom vlákne \cite{endgame}. Pomocou prislušného API volania vieme nainštalova hook na špecifickú udalos v systéme (napr. stlaèenie klávesy), pre konkrétne vlákno v systéme. Taktie vieme špecifikova smerník na funkciu, ktorá sa má zavola ak daná udalos nastane. V tejto funkcii následne vieme urèi e sa má naèíta napr. škodlivé DLL. Môeme si všimnú e väšèina techník sa samotné naèítanie kódu vyuíva metódu naèítania škodlivého DLL do regulérneho procesu a hlavné rozdiely spoèívajú najmä v riešení ako donúni cudzí proces túto funkcionalitu vyvola.

\item 
\textbf{APC Injection}
\noindent \\
Škodlivı softvér môe vyuíva vıhody tzv. \textit{Asynchronous Procedure Calls} (APC), aby prinútil iné vlákno spusti svoj vlastnı kód \cite{endgame}. Túto funkcionalitu vie dosiahnú tak, e vloí dané vlákno do APC fronty. Kadé vlákno má vlastnú APC frontu, z ktorej vykonáva volania ak sa nachádza v pozastavenom stave a èaká na konkrétne udalosti. Podobne ako v predchádzajúcich prípadoch môe malvér do APC fronty vloi smerník na funkciu, v ktorej sa naèíta škodlivé DLL. Malvér zvyèajne h¾adá ¾ubovo¾né vlákno ktoré sa nachádza v špeciálnom stave, pri ktorom vykonáva postupne poloky v APC fronte. Takıchto vláken je väèšinou v systéme ve¾a.

\item 
\textbf{Extra windows memory injection}
\noindent \\
Tento spôsob schovávania softvéru sa spolieha na monos špecifikova dodatoènú pamä pri registrácii aplikaènıch okien v systéme. Pri registrácii nového okna aplikácie, softvér špecifikuje ïalšie bajty pamäte, ktoré rozšíria ve¾kos alokovanej pamäte pre spustenú aplikáciu \cite{endgame}, nazıvané aj \textit{Extra Windows Memory}(EWM). V tejto èasti ale nevzniká dostatok miesta na uloenie dát. Aby sa toto obmedzenie obišlo, škodlivı softvér zapíše kód do zdie¾anej pamäte a do EWM vloí ukazovate¾ na danú èast. Do tejto rozšírenej èasti zie¾anej pamäte ïalej softvér zapíše smerník na funkciu, ktorá obsahuje kód na naèítanie malvéru. Malvér môe nakoniec vyvola spustenie tohoto kódu pomocou konkrétnych Windows API volaní.
\end{itemize}
\vspace{20px}
\subsection{Súèasnı malvér}
\noindent \\
Táto kapitola obsahuje opis jednotlivıch vzoriek škodlivého kódu z roku 2019, ktoré boli detegované spoloènosami ako Avast a McAfee. Tieto vzorky sú najèastejšie vyuívané v oblasti Európy. Kapitola obsahuje bliší opis jednotlivıch vzoriek, ich vyuitie, pouité spôsoby útokov a ukrytie malvéru v systéme.

\begin{itemize}
\item
\textbf{Sodinokibi}
\noindent \\
Tento malvér bol detekovanı v období okolo apríla 2019. Patrí do rodiny ransomvéru, ktorıch cie¾om je zašifrova dáta v zariadení a následne za dešifrovanie pıta peniaze \cite{sinobiki} (väèšinou v podobe kryptomeny). Názov bol objavenı v heši, ktorı obsahoval názov \textit{Sodinokibi.exe}. Vírus sa šíri sám zmeuívaním zranite¾nosti v serveroch, ktoré pouívajú \textit{Oracle WebLogic}. Kód je navrhnutı tak, aby rıchlo vykonával šifrovanie špecifickıch súborov, definovanıch v konfigurácii ransomvéru. Prvou akciou škodlivého kódu je naèíta všetky externé funkcie potrebné poèas behu programu. Technika vyuívaná na ukrytie malvéru je \textit{Portable Executable Injection}. Analıza spoloènosti McAfee ukazuje podobnos s inım starším malvérom GandCrab.

\item
\textbf{Emotet}
\noindent \\
Emotet je malvér, ktorı sa primárne šíri pomocou rôznych spam emailov \cite{emotet2}. Na infikovanie zariadenia pouíva rôzne skripty, makrá v dokumetoch alebo linky. Emotet sa teda spolieha najmä na techniky sociálneho ininierstva. Prezentuje sa ako hodnovernı zástupca napr. banky, rôznych internetovıch obchodov, a pod. Emotet sa prvıkrát objavil v roku 2014 kedy vyuíval na infikovanie rôzne JavaScript súbory \cite{emotet}. V roku 2019 sa tento vírus objavil znova tentokrát u v pokroèilejšej verzii.  V novej verzii je Emotet u polymorfnım škodlivım kódom, èo mu umoòuje vyhnú sa klasickej detekcii. Emotet môe navyše generova falošné funkcionalitu, ak je spustenı vo virtuálnom prostredí èo zhoršuje jeho detekciu systéme.

\item
\textbf{ZeuS}
\noindent \\
Prvıkrát odhalenı v roku 2007 sa Zeus Trojan, ktorı sa èasto nazıva Zbot, stal jednım z najúspešnejších botnetov na svete a postihol milióny poèítaèov \cite{zeus2}. Taktie bolo vytvorernıch mnostvo variantov, ktoré boli zaloené na tomto malvéri. Po èase sa znovu objavil v pozmenenej podobe so zameraním na odchytávanie bankovıch operácii (odchytávanie prihlasovacích údajov do internet bankingu). Dosahuje to prostredníctvom monitorovania webovıch stránok a zaznamenávania klávesov. Keï malvér zistí, e sa pouívate¾ nachádza na webovej stránke banky, zaène zaznamenáva stlaèenia klávesov pouité na prihlásenie. Infekcia prebieha pomocou spamov. Keï uívate¾ klikne na odkaz v správe alebo stiahne obsah súboru, spolu s ním stiahne a spustí aj makro, ktoré po nainštalovaní umoòuje sledovanie zariadenia. 

\item
\textbf{Dridex}
\noindent \\
Dridex je známy trójsky kôò, ktorı sa špecializuje na kráde kreditnıch údajov v online bankovníctve. Tento typ škodlivého kódu sa objavil v roku 2014 a stále sa postupne vyvíja. Novı variant Dridex je schoplnı vyhnú sa detekcii tradiènımi antivírusovımi produktami. Tento malvér je v súèastnosti schopnı detekova pribline 25 a 30 percent aktuálnych antivírusovıch softvérov. \cite{dridex}

\item
\textbf{Mirai}
\noindent \\
\textit{Mirai} je samošírite¾nı typ škodlivého súboru na vytvorenie botnetu. Zdrojovı kód pre \textit{Mirai} bol autormi verejne sprístupnenı po úspešnom a dobre propagovanom útoku na webovú stránku Krebbs. Kód botnetu Mirai infikuje zariadania pripojené k internetu, ktoré vyuívajú telnet protokol (sieovı komunikaènı protokol zaloenı na TCP) na nájdenie tıch, ktoré stále pouívajú svoje predvolené uivate¾ské meno a heslo. Úèinnos málvéru \textit{Mirai} je spôsobená jeho schopnosou infikova desiatky tisíc tıchto nezabezpeèenıch zariadení a koordinova ich tak, aby zaèali útok DDoS proti vybranej obeti. \cite{mirai}

Mirai má dve hlavné zloky, samotnı vírus a C\&C server, ktorı ovláda kompromitované zariadenia (BOT) a posiela im pokyny na spustenie jedného z útokov proti jednej alebo viacerım obetiam. Proces skenera prebieha nepretrite na kadom infikovanom zariadení pomocou protokolu telnet (na porte TCP 23 alebo 2323)

C\&C predstavuje jednoduché rozhranie príkazového riadku, ktoré umoòuje útoèníkovi urèi algoritmus, IP adresu obete a trvanie útoku. C\&C tie èaká na to, aby jej existujúce BOT-y vrátili novoobjavené adresy zariadení, ktoré pouíva na ïalšie rozširovanie botnetu. Algoritmy sú konfigurovate¾né z C\&C, ale v predvolenom nastavení má \textit{Mirai} tendenciu náhodne rozde¾ova rôzne polia (ako sú èísla portov, poradové èísla, identifikátory atï.).

\item
\textbf{Osiris}
\noindent \\
Osiris je odvodenı od malvéru Kronos, ktorı sa zameriaval na bankovnívctvo. Podobne ako Kronos, je Osiris modernejšou verziou bankového trójskeho koòa \cite{osiris}. Táto verzia malvéru vyuíva na skrıvanie metódu \textit{process hollowing}. Umoòuje mu vydáva sa za legitímne procesy. Malvér sa šíri vydávaním sa za legitímny spustite¾nı súbor (útoky zaznamenné s malvérom Osiris boli dokumenty Microsoft Word). Vydávanie sa za inı oficiálny softvér znaène sauje identifikáciu malvéru a obmedzuje monosti na zastavenie útoku \cite{osiris2}. Malvér v dokumetoch Word obsahoval aj makrá, ktoré po spustení stiahli další škodlivı malvér, ktorı umouje zahåti zariadenia alebo sai detekcu

\item
\textbf{Loki}
\noindent \\
Loki je ïalšou variáciou staršieho malvéru Kronos. Rovnako ako Osiris, aj Loki vyuíva na svoje ukrytie metódu \textit{process hollowing}. Loki sa zameriava na krádee osobnıch údajov ako napr. prihlasovacie údaje a heslá. Od augusta 2018 a do súèasnosti sa Loki zameriava na firemné poštové schránky prostredníctvom phishingovıch a spamovıch e-mailov. Phishingové e-maily zahàòajú prílohu súboru s príponou .iso, ktorá sahuje a spúša škodlivı softvér.
\end{itemize}

Celkovı preh¾ad pouítıch techník v súèasnım vzorkách škodlivého kódu môeme vidie v tabu¾ke è.\ref{modulyVlastnosti}.
\begin{table}[!htbp]
	\begin{center}
		\begin{tabular}{|p{6cm}|c|c|c|c|c|c|c|c|}
			\hline
			& \multicolumn{7}{c|}%
			{\textbf{Technika ukrıvania}}\\ \hline
			\textbf{Názov malvéru} &\begin{sideways} Sodinokibi \end{sideways} &\begin{sideways} Emotet \end{sideways} &\begin{sideways} ZeuS \end{sideways} & \begin{sideways} Dridex \end{sideways} & \begin{sideways} Mirai \end{sideways} & \begin{sideways} Osiris \end{sideways}  & \begin{sideways} Loki \end{sideways} \\ \hline
			\textit{DLL Injection} & & \xmark & \xmark & & \xmark & &	\\ \hline
			\textit{Process hollowing} & & & & & & \xmark & \xmark	\\ \hline
			\textit{Thread Execution Hijacking} & & & & & & & 	\\ \hline
			\textit{Portable Executable Injection}  & \xmark & & & \xmark & & &	\\ \hline
			\textit{Hook injection}  & & & & & & &	\\ \hline
			\textit{APC Injection}  & & & & & & &	\\ \hline
			\textit{Extra windows memory injection} & & & & & & &	\\ \hline
		\end{tabular}
	\caption{Techniky ukrıvania èinnosti vyuívané súèasnım malvérom.}
\label{modulyVlastnosti}
\end{center}
\end{table}

\section{Process hollowing}
\noindent

Zvolenı spôsob ukrytia malvéru, ktorım sme sa v tejto práci zaoberali je \textit{process hollowing}. Nasledujúca kapitola sa venuje spôsobu akım sa malvér môe ukry pomocou spomínanej techniky. Taktie obsahuje potenciálne API funkcie pomocou ktorıch môe by technika \textit{process hollowing} implementovaná.

\begin{figure}[!htbp]
	\centering
	\includegraphics[width=12cm]{img/Diagram.jpg}
	\caption{ Ukáka zmien adresného priestoru poèas Hollowingu.}
	\label{vzhladobr}
\end{figure}

\subsection{Princíp}

Princíp ukrytia malvéru, ktorı vyuíva \textit{process hollowing} je do istej miery podobnı technike \textit{DLL Injection}. Hlavnı cie¾ metódy spoèíva v ukrytí škodlivého kódu do beného procesu, ktorı v systéme Windows spôsobuje èo najmenšie podozrenie \cite{hollowing}. Takımto procesom môe by napríklad \textit{svchost.exe}, ktorı je v systéme bene spustenı aj vo viacerıch inštanciách. \textit{Process hollowing} vytvorí pozastavenı proces \textit{svchost.exe} (prípadne získa prístup u k beiacemu procesu) a odmapuje jeho pamä. Po odmapovaní alokuje dostatok miesta vo virtuálnom adresnom priestore procesu. Následne, po alokácii nakopíruje škodlivı kód a nastaví novı vstupnı bod programu. Po ukonèení tıchto krokov obnoví pozastavenı proces. Vısledkom je navonok beiaci štandardnı proces \textit{svchost.exe}, ktorı ale vo vnútri vykonáva škodlivú èinnos. Schematické znázornenie priebehu tejto techniky môeme vidie na obrázku è.\ref{vzhladobr}.

\subsection{Vyuívané API funkcie}
\textit{Process hollowing} vyuíva na svoje fungovanie rôzne štandardné API volania. Nasledujúce nami vybrané API funkcie\cite{winapi}, môu by vyuité pri technike \textit{rocess hollowing}:
\begin{itemize}
\item
\textbf{CreateThread}
\\
Vytvorí nové vlákno vo virtuálnom adresnom priestore procesu, ktorı danú funkciu zavolal.
\item
\textbf{CreateRemoteThread}
\\
Vytvorí vlákno, ktoré beí vo virtuálnom adresovom priestore iného procesu.
\item
\textbf{CreateRemoteThreadEx}
\\
Funkcia vytvára vlákno, ktoré sa spúša vo virtuálnom adresovom priestore iného procesu a prípadne špecifikujte rozšírené atribúty, ako napr. nastavenie na ktorom procesore bude dané vlákno bea.
\\
\\
\item
\textbf{ResumeThread}
\\
Funkcia dekrementuje hodnotu, ktorá špecifikuje, ko¾krát bolo vlákno pozastavané. V prípade ak sa hodnota dostane na nulu, vlakno je obnovené. V opaènom prípade ostáva pozastavené. 
\item
\textbf{SuspendThread}
\\
Pozastavenie vykonávanie èinnosti špecifikovaného vlákna.
\item
\textbf{SwitchToThread}
\\
Spôsobuje prepnutie aktuálneho vlákna, na vlákno, ktoré je pripravené bea na procesore. Tento vıber vykonáva operaènı systém.
\item
\textbf{CreateProcessA}
Vytvorí novı proces a jeho hlavné vlákno. Novı proces beí s rovnakımi oprávneniami ako proces, ktorı danú funkciu zavolal.
\item
\textbf{VirtuallAlloc}
\\
Alokuje alebo mení oprávnenia stránok vo virtuálnom adresom priestore procesu, ktorı danú funkciu zavolal. Alokovaná pamä je automaticky inicializovaná na nulu.
\item
\textbf{VirtualAllocEx}
\\
Funguje rovnako ako \textit{VirtualAlloc}, s tım rozdielom, e alokuje pamä v rámci virtuálneho adresného priestoru iného procesu.
\item
\textbf{WriteProcessMemory}
\\
Zapisuje údaje do pamäti v zadanom procese. Celá oblas, do ktorej sa zapisuje, musí ma potrebné oprávnenia na zápis.
\item
\textbf{ReadProcessMemory}
\\
Èíta údaje z virtuálneho adresného priestoru špecifikovaného procesu.
\item
\textbf{SetThreadContext}
\\
Nastavuje kontext (t.j. obsah registrov) pre špecifikované vlákno.
\item
\textbf{NtUnmapViewOfSection}
\\
Odmapuje pamä vybraného procesu.
\\
\end{itemize}
\section{Existujúce riešenia na detekciu}\label{existingsolutions}
\noindent
Doposia¾ známe existujúce riešenia na detekciu techniky \textit{process hollowing} vyuívanej niektorımi vzorkami škodlivého kódu, sú urèené na forenznú analızu. Táto analıza prebieha a po infikovaní zariadenia malvérom a zistením, e škodlivı kód sa u v zariadení nachádza. Riešenia spomínané v tejto kapitole sa teda nezameriavajú na detekciu techniky v reálnom èase. 

\subsection{PHDetection}

\textit{PHDetection} h¾adá moduly, od ktorıch závisí pôvodnı spustite¾nı program \cite{phdetection}. \textit{PHDetection} kontroluje èi sú dané moduly naèítané do pamäte programu. Ak nástroj nájde moduly, na ktorıch závisí dotyènı program (t.j. sú zapísané v IAT) ale nenájde ich v pamäti procesu, \textit{PHDetection} deteguje e sa jedná o \textit{process hollowing} a pôvodnı proces bol nahradenı inım. Existuje mnoho spustite¾nıch súborov, ktoré nezávisia od ve¾kého poètu modulov a kvôli tomu nástroj analyzuje aj tabu¾ku importov, v ktorej sa nachádzajú moduly, ktoré sa majú naèíta a poèas prvého pouitia. To znamená e DLL súbor sa naèíta do pamäte procesu a v momente, kedy sa zavolá prvá funkcia z tohoto modulu. \textit{PHDetection} teda postupne prechádza všetky beiace procesy a analyzuje naèítané moduly. V prípade ak danı modul nastavenı na neskoršie naèítanie a ešte sa nenachádza v pamäti, nástroj porovnáva èasové znaèky spustite¾ného súboru na disku a v pamäti. Program bol implementovanı v jazyku C++.

\subsection{HollowFind}

\textit{Hollowfind} je plugin pre nástroj \textit{Volatility} na detekciu rôznych typov techniky \textit{process hollowing} pouívanıch škodlivım kódom \cite{hollowfind}. Plugin sa zameriava taktie na rôzne formy obfuskácie danej techniky s cie¾om saenia forenznej analızy. Plugin deteguje metódu na základe porovnávania VAD a PEB tabuliek. VAD tabu¾ka je stromová štruktúra reprezentujúca jednotlivé stránky vo virtuálnom adresnom priestore a PEB tabu¾ka obsahuje rôzne informácie o konkrétnom procese. Príkladom môe by chıbajúca cesta k spustite¾nému súboru vo VAD tabu¾ke alebo rôzne bázové adresy procesu v PEB a VAD tabu¾ke.

\section{Algoritmus na detekciu}
\noindent
\begin{figure}[!htbp]
	\centering
	\includegraphics[width=10cm]{img/Automat.jpg}
	\caption{Koneènı stavovı automat reprezentujúci postupnos API volaní vedúcich k ukrytiu malvéru.}
	\label{automat}
\end{figure}

Nami navrhnutı algoritmus na detekciu techniky \textit{process hollowing} je zaloenı na koneènom stavovom automate. Automat tvorí celkovo šes prechodovıch stavov (a jeden poèiatoènı a jeden koneènı stav). Cez tieto stavy postupne prechádzame pri zachytávaní niektorıch API volaní. Automat obsahuje nasledujúce stavy:
\begin{itemize}
	\item \textbf{Vytvorenie pozastaveného procesu}
	\item \textbf{Odmapovanie pamäte}
	\item \textbf{Alokácia pamäte}
	\item \textbf{Skopírovanie škodlivého kódu}
	\item \textbf{Nastavenie IP}
	\item \textbf{Spustenie procesu}
\end{itemize}

Vstupné symboly, ktoré spôsobujú prechody v koneènom automate sú v našom prípade API volania. Nami zvolené API volania môeme rozdeli do nasledujúcich skupín:

\begin{itemize}
\item
\textbf{WAPI1} -
sú API funkcie, ktoré umoòujú vytvára nové vlákna/procesy alebo získa prístupy do u existujúcich vlákien/procesov, t.j. \textit{CreateThread}, \textit{SuspendThread}, \textit{CreateProcessA}.
\item
\textbf{WAPI2} -
predstavujú API volania primárne urèené na odmapovanie pamäte existujúceho procesu, t.j. \textit{NtUnmapViewOfSection}.
\item
\textbf{WAPI3} -
volania slúiace na alokáciu pamäte vo virtuálnom adresnom priestore procesu, t.j. \textit{VirtualAlloc}, \textit{VirtualAllocEx}.
\item
\textbf{WAPI4} -
tieto funkcie umoòujú manipulova s pamäou;kopírovanie pamäte, zapisovanie a èítanie, t.j. \textit{WriteProcessMemory}, \textit{CopyMemory}, \textit{ReadProcessMemory}.
\item
\textbf{WAPI5} - API volanie, ktoré nastavuje kontext daného vlákna a umoòujú nastavi IP - \textit{SetThreadContext}. 
\item
\textbf{WAPI6} -
poslednou skupinou sú API volania, ktoré spúšajú pozastavené vlákno, t.j. \textit{ResumeThread}.
\end{itemize}

Algoritmus na detegovanie funguje na jednoduchom princípe. Podozrivú vzorku spustíme a zachytávame vyššie spomínané API volania. Na základe tıchto volaní postupne prechádzame stavmi koneèného automatu. Ak sa postupne dostaneme dostaneme do posledného stavu, prepokladáme e nastal \textit{process hollowing}. Celkové znázornenie automatu môeme vidie na obrázku è.\ref{automat}.

\subsection{Koneènı stavovı automat}

Koneènı automat je teoretickı vıpoètovı model pouívanı v informatike na štúdium rôznych formálych jazykoch. Popisuje ve¾mi jednoduchı poèítaè, ktorı môe by v jednom z nieko¾kıch stavov, medzi ktorımi prechádza na základe symbolov, ktoré èíta zo vstupu. Mnoina stavov je koneèná. Automat nemá iadnu ïalšiu pamä, okrem informácie o aktuálnom stave. V informatike sa rozlišuje okrem základného deterministického èi nedeterministického automatu tie Mealyho a Moorov automat.

Koneènı automat je definovanı ako usporiadaná pätica ($\Sigma$, $K$, $q_0$, $\delta$, $F$) kde:

\begin{itemize}
	\item $\Sigma$ je koneèná neprázdna mnoina vstupnıch symbolov, nazıvanıch aj abeceda. V našom prípade sa jedná o jednotlivé API volania.
	\item $K$ je koneèná mnoina stavov ako napr. \textbf{alokácia pamäte} alebo \textbf{process hollowing}.
	\item $q_0$ je poèiaènı stav a platí $q_0 \in K$. V prípade našeho automatu sa jedná o stav \textbf{štart}, v ktorom sa èaká na prvé vstupné symboly, ktoré reprezentujú napr. vytvorenie pozastaveného vlákna.
	\item $\delta$ je prechodová funkcia, popisujúca prechod medzi jednotlivımi stavmi. Platí: $\delta: K \times \Sigma \to K$.
	\item $F$ je moina finálnych akceptaènıch stavov. V našom automate predstavuje stav, v ktorom detegujeme \textit{process hollowing}.
\end{itemize}

Na zaèiatku sa automat nachádza v definovanom poèiatoènom stave. Ïalej, v kadom kroku preèíta jeden symbol zo vstupu a prejde do stavu, ktorı je danı hodnotou, ktorá v prechodovej tabu¾ke zodpovedá aktuálnemu stavu a preèítanému symbolu. Potom pokraèuje èítaním ïalšieho symbolu zo vstupu a ïalším prechodom pod¾a prechodovej tabu¾ky.

Pod¾a toho, èi automat skonèí po preèítaní vstupe v stave, ktorı patrí do mnoiny akceptaènıch stavov, platí, e automat buï danı vstup prijal, alebo neprijal. Mnoina všetkıch reazcov, ktoré danı automat príjme, tvorí regulárny jazyk.

\subsection{Matica koneèného stavového automatu}
Matica reprezentuje prechody medzi jednotlivımi stavmi koneèného stavového automatu. Tieto prechody sú definované ako volania vybranıch API funkcií, ktoré posúvajú automat cez jednotlivé stavy pod¾a toho v akom stave je aktuálne automat a do akého nového stavu sa automat dostane. Koneèná mnoina stavov je reprezentovaná stavmi \textbf{štart}, \textbf{vytvorenie procesu}, \textbf{alokácia pamäte}, \textbf{kopírovanie malvéru}, \textbf{nastavenie IP} a \textbf{spustenie vlákna}. Poèiatoènı stav automatu je \textbf{štart} a koneènı stav je \textbf{process hollowing}, ktorı oznaèuje e nastalo injektovanie kódu. Maticu prechodov mono vidie v tabu¾ke è.\ref{maticaPrechodov}.

\begin{table}[!htbp]
	\begin{center}
		\begin{tabular}{|p{5cm}|c|c|c|c|c|c|c|}
			\hline
			& \multicolumn{7}{c|}%
			{\textbf{Prechodové stavy}}\\ \hline
			\textbf{Volané API funkcie} &\begin{sideways} Štart \end{sideways} &\begin{sideways} Vytvorenie procesu/ Získanie prístupu do procesu \end{sideways} &\begin{sideways} Odmapovanie pamäte existujúceho procesu \end{sideways} &\begin{sideways} Alokácia virtuálnej pamäte \end{sideways} & \begin{sideways} Kopírovanie malvéru do alokovanej pamäte \end{sideways} & \begin{sideways} Nastavenie IP na spustenie malvéru \end{sideways} & \begin{sideways} Spustenie vlákna/ Spustenie pozastaveného procesu \end{sideways}  \\ \hline
			Skratky stavov & S0 & S1 & S2 & S3 & S4 & S5 & S6 \\ \hline
			CreateThread & S1 & S1 & S1 & S1 & S1 & S1 & S1 \\ \hline
			CreateRemoteThread & S1 & S1 & S1 & S1 & S1 & S1 & S1 \\ \hline
			CreateRemoteThreadEx & S1 & S1 & S1 & S1 & S1 & S1 & S1 \\ \hline
			CreateProcessA & S1 & S1 & S1 & S1 & S1 & S1 & S1 \\ \hline
			CreateProcessW & S1 & S1 & S1 & S1 & S1 & S1 & S1 \\ \hline
			SwitchToThread & S1 & S1 & S1 & S1 & S1 & S1 & S1 \\ \hline
			OpenThread & S1 & S1 & S1 & S1 & S1 & S1 & S1 \\ \hline
			SuspendThread & S1 & S1 & S1 & S1 & S1 & S1 & S1 \\ \hline
			NtUnmapViewOfSection & S0 & S2 & S2 & S3 & S4 & S5 & S6 \\ \hline
			VirtualAlloc & S0 & S1 & S3 & S3 & S4 & S5 & S6 \\ \hline
			VirtualAllocEx & S0 & S1 & S3 & S3 & S4 & S5 & S6 \\ \hline
			CopyMemory & S0 & S1 & S2 & S4 & S4 & S5 & S6 \\ \hline
			ReadProcessMemory & S0 & S1 & S2 & S4 & S4 & S5 & S6 \\ \hline
			WriteProcessMemory & S0 & S1 & S2 & S4 & S4 & S5 & S6 \\ \hline
			ResumeThread & S0 & S1 & S2 & S3 & S4 & S6 & S6 \\ \hline
			SetThreadPriority & S0 & S1 & S2 & S3 & S5 & S5 & S6 \\ \hline
			
		\end{tabular}
		\caption{Matica prechodov medzi stavmi pri API volaniach.}
		\label{maticaPrechodov}
	\end{center}
\end{table}

\section{Implementácia}\label{implementation}

Pre implementáciu riešenia sme si zvolili programovací jazyk C++, pretoe našim primárnym testovacím prostredím bol operaènı systém Windows. Aplikáciu sme implementovali v prostredí \textit{Microsoft Visual Studio 2019}. Celkovú štruktúru našej aplikácie môeme vidie na obrázku è.\ref{modul}.

\begin{figure}[!htbp]
	\centering
	\includegraphics[width=12cm]{img/UML2.jpg}
	\caption{Zobrazenie jednotlivıch modulov riešenia a vzahov medzi nimi.}
	\label{modul}
\end{figure}

Aplikácia sa skladá z troch základnıch modulov:
\begin{itemize}
	\item \textit{DLL na zachytávanie API volaní}; tento modul sa skladá z dynamickej kninice \textit{Hook.dll}, ktorá slúi na zachytávanie API volaní. Hlavnım cie¾om nami implementovanej kninice \textit{Hook.dll} je zachytáva zvolené API volania a zapisova ich do súboru, spolu s jedineènım identifikátorom. Tento identifikátor slúi na definovanie jednoznaèného poradia v akom sa volali jednotlivé API funkcie a taktie na u¾ahèenie èítania ïalšími modulmi.
	\item \textit{Modul na injektovanie DLL do vzorky}; cie¾om modulu je injektova vyššie spomínanı DLL súbor do pouívate¾om vybranej vzorky. Injektovanie prebieha štandardnou formou, ako pri škodlivom kóde: získame prístup k procesu, alokujeme pamä na cestu k DLL súboru a spustíme vlákno, ktoré danú kninicu naèíta. 
	\item \textit{Koneènı automat}; táto èas aplikácie má viacero funkcií. Samotnı koneènı automat sa naèítava z konfiguraèného súboru (v ktorom sú definované jednotlivé prechody). Modul v pravidelnıch intervaloch èíta súbor so zapísanımi API volaniami a pod¾a preèítanıch záznamov sa posúva v koneènom automate. V momente keï sa dostaneme do koneèného stavu, aplikácia oznámi detekciu techniky \textit{process hollowing}.
\end{itemize}

\subsection{Algoritmus}

Celkovı priebeh detekèného algoritmu môeme vidie na obrázku è.\ref{UMLDiagram}. Aplikácia na zaèiatku inicializuje pomenovanı mutex, ktorı slúi na synchronizáciu èítania/zapisovania súboru s API volaniami. Keïe k nemu pristupujeme z dvoch procesov, bolo treba vytvori pomenovanı mutex v systéme. Tento mutex sa vytvára v hlavnej detekènej aplikáciii a pristupujeme k nemu taktie z nášho DLL. Inicializáciu mutexu môeme vidie vo vıpise è.\ref{vypiS5}.

\begin{figure}[!htbp]
	\centering
	\includegraphics[width=12cm]{img/UML.jpg}
	\caption{Stavovı diagram priebehu detekcie.}
	\label{UMLDiagram}
\end{figure}

\begin{lstlisting}[caption=Vytvorenie mutexu.,label={vypiS5}]
HANDLE mutexOnThreadSafe;
mutexOnThreadSafe = CreateMutex(NULL, FALSE, TEXT("MutexOnThreadSafe"));
\end{lstlisting}

Po inicializácii mutexu sa injektuje DLL do vzorky, èím spustíme zber dát a taktie sa naèíta koneènı automat z konfiguraèného súboru. Ukáku konfiguraèného súboru pre API volanie \textit{ResumeThread} môeme vidie na obrázku è.\ref{Config}.

\begin{figure}[!htbp]
	\centering
	\includegraphics[width=10cm]{img/configuration.png}
	\caption{Ukáka konfiguraèného súboru pre API ResumeThread.}
	\label{Config}
\end{figure}

Konfiguraènı súbor  sa skladá z troch ståpcov a obsahuje definíciu prechodov pre kadú nami vybranú API funkciu. Kadı jeden prechod je definovanı trojicou: aktuálny stav, API volanie, novı stav. Ukáku súboru so zapísanımi API volaniami môeme vidie na obrázku è.\ref{Result}. Jednotlivé riadky tvoria dvojice: jednoznaènı identifikátor a názov API funkcie, ktorá bola volaná škodlivou vzorkou.

\begin{figure}[!htbp]
	\centering
	\includegraphics[width=9cm]{img/Result.jpg}
	\caption{Ukáka zapisovanıch API volaní.}
	\label{Result}
\end{figure}

\vspace{1cm}

Po poèiatoènej inicializácii sa spustí vlákno, ktoré v pravidelnıch intervaloch èíta súbor so zapísanımi API volaniami. Pred samotnım èítaním je potrebné uzamknú zdielanı mutex aby sme zabezpeèili integritu dát. Vo vlákne sa následne naèítajú najnovšie záznamy (po dokonèení èítania sa vdy uloí identifikátor posledného naèítaného záznamu) a aktualizuje sa koneènı automat. Ak sa automat nachádza v koneènom stave, aplikácia oznámi detekciu techniky \textit{process hollowing}. V opaènom prípade vlákno uvo¾ní mutex a znovu sa uspí.
 
\subsection{Modul na zber dát}
\noindent

Modul na zber dát predstavuje dynamickú kninicu \textit{Hook.dll} pomocou ktorej sa odchytávajú API volania. Samotnı modul sa skladá z dvoch èastí. Prvou èasou je definícia smerníka na pôvodnu API funkciu a definícia novej funkcie pre konkrétne API. Táto funkcia najprv vykoná našu funkcionalitu a následne zavolá pôvodnú funkciu, viï vıpis è.\ref{vypiS3}.

\begin{lstlisting}[caption=Definícia API volania SetThreadContext.,label={vypiS3}]
static BOOL(__stdcall *RealSetThreadContext)(HANDLE, const CONTEXT*) = SetThreadContext;

BOOL WINAPI HookSetThreadContext(HANDLE hThread, const CONTEXT* lpContext)
{
writeFunctionToFile("SetThreadContext");
return RealSetThreadContext(hThread, lpContext);
}
\end{lstlisting}

Naša funkcionalita, ktorá sa má vykona pri API volaniach je definovaná vo funkcii \textit{writeFunctionToFile}. Cie¾om funkcie je uzamknú zdie¾anı mutex a následne zapísa do súboru jednoznaènı identifikátor spolu s názvom volanej API funkcie. Implementáciu funkcie \textit{writeFunctionToFile} môeme vidie vo vıpise è.\ref{vypis1}.

\vspace{5cm}

\begin{lstlisting}[caption=Implementácia funkcie writeFunctionToFile.,label={vypis1}]
void writeFunctionToFile(std::string originalFunkcion) 
{
	DWORD ret = WaitForSingleObject(hMutex, INFINITE);
	
	if (ret == WAIT_OBJECT_0)
	{
		std::ofstream myFile("api_data.txt", std::ofstream::app | std::ofstream::out);
		
		if (myFile.is_open())
		{
			myFile << Id << ";" + originalFunkcion << endl;
			myFile.close();
		}
		Id++;
		ReleaseMutex(hMutex);
	}
}
\end{lstlisting}

\begin{lstlisting}[caption=Nahradenie pôvodnej funkcie SetThreadContext.,label={vypiS4}]
switch (ul_reason_for_call)
{
	case DLL_PROCESS_ATTACH:
	{
		DetourAttach(&(PVOID&)RealSetThreadContext, HookSetThreadContext);
		DetourTransactionCommit();
		break;
	}
	case DLL_PROCESS_DETACH:
	{
		DetourDetach(&(PVOID&)RealSetThreadContext, HookSetThreadContext);
		DetourTransactionCommit();
		break;
	}
}
\end{lstlisting}

Druhá èas aplikácie nahrádza volanie pôvodnej API funkcie modifikovanou funkciou. Ako môeme vidie vo vıpise è.\ref{vypiS4}, pôvodnú funkciu \textit{SetThreadContext} nahradíme funkciou \textit{HookSetThreadContext}. Takımto spôsobom je nutné špecifikova všetky API volania, ktoré chceme zachytáva.

\subsection{Detours}

Naša aplikácia vyuíva kninicu \textit{Detours} na sledovanie API volaní v module na zber dát. \textit{Detours} je kninica urèená na monitorovanie API volaní v systéme Windows \cite{detours}.  Táto kninica podporuje rovnako 32 tak aj 64 bitovú verziu operaèného systému Windows. Kninica u¾ahèuje prácu vıvojárom, ktorı pracujú s rozhraním API volaní. Detours nahrádza volanie cie¾ovej funkcie skokom na pouívate¾om zadanú funkciu. Okrem základnıch funkcií obsahuje \textit{Detours} aj funkcie na úpravu tabu¾ky importov, pripojenie ¾ubovo¾nıch segmentov údajov k existujúcim binárnym súborom a na naèítanie DLL do nového procesu. Po naèítaní do procesu môe DLL kninica nahradi akúko¾vek funkciu v procese, ako sú napríklad rozhrania Windows API. 

\section{Vısledky}\label{results}
Našu aplikáciu sme testovali v prostredí \textit{Virtual Box}, na systéme Windows 10. Hlavnım cie¾om testov bolo vyskúša naše riešenie na reálnych vzorkách škodlivého kódu, ktorı vyuíva \textit{process hollowing}. Pred samotnımi testami s reálnymi vzorkami sme poèas vıvoja a experimentovania pracovali s ukákovou implementáciou metódy \textit{process hollowing}, dostupnej na \cite{gitHub}. Táto aplikácia dokáe injektova ¾ubovolnı spustite¾nı kód do procesu zadaného prostredníctvom argumentov príkazového riadku. Po dokonèení prvotnıch experimentov, kedy sme úspešne detegovali \textit{process hollowing} na testovacej aplikácii, sme sa posunuli na škodlivé vzorky. V nasledujúcej kapitole uvádzame popis experimentov so škodlovımi vzorkami a vısledky, ktoré sme dosiahli.

\subsection{Škodlivé vzorky}

Primárnym cie¾om experimentov bolo otestova, èi naše riešenie dokáe detegova injektovanie kódu pomocou techniky \textit{process hollowing} aj na reálnych vzorkách. Prvım krokom bolo získa nejaké vzorky, ktoré danú techniku vyuívajú. Tieto informácie sme získavali z rôznych blogov, resp. sluieb ktoré sa venujú dynamickej analıze malvéru v sandboxe ako napr. \textit{any.run}\cite{anyRun}. Samotné vzorky sme následne získavali z \cite{virusTotal, anyRun}. V tabu¾ke è.\ref{vzorky} môeme vidie vısledky, ktoré sme dosiahli.

\begin{table}[!htbp]
	\begin{center}
		\begin{tabular}{|p{4,5cm}|c|c|c|}
			\hline
			\textbf{Názov vzorky} &  \textbf{MD5}  & \textbf{Detekcia} & \textbf{Èas}\\ \hline
			MSIL/Injector.DXQ & 706630a77f06ef8fb90eb312fa2cbfe6 & \cmark & 2,203 s\\ \hline
			MSIL/Kryptik.FQF & 3f385d11f6b438ea963cd49e818b9d90 & \cmark & 1,655 s\\ \hline
			MSIL/Injector.DXQ & 9e298807729dff89b56f68f4d42ffd93 & \cmark & 1,101 s \\ \hline
			Win32/Spy.Zbot.JF & 3cfc97f88e7b24d3ceecd4ba7054e138 & \xmark & -\\ \hline
			Win32/Kryptik.AVWC & 0d42179ff6c448697b67056aecc91c67 & \xmark & -\\ \hline
			Win32/Spy.Zbot.YW & ec2dacdbcf194c1e8c8db2dbec605b83 & \xmark & -\\ \hline
			Win32/Kryptik.GLKL & 6c129b7ed58900286d6cd3a4e85ca15b & \xmark & -\\ \hline
			Win32/Filecoder.Natas.A & f592e7faba96a23ee25ff25f3779f44f & \xmark &-\\ \hline	
		\end{tabular}
		\caption{Vısledky experimentov so škodlivımi vzorkami.}
		\label{vzorky}
	\end{center}
\end{table}

Samotné experimenty prebiehali následovne. Do predpripraveného adresára sme si pripravili našu finálnu aplikáciu spolu so vzorkami. Našu aplikáciu sme spúšali vdy s jednou konkrétnou vzorkou. Po spustení, detekèná aplikácia injektovala nami vytvorenı DLL súbor, urèenı na sledovanie API volaní, do konkrétnej vzorky. Èasovı limit na jednu vzorku sme si stanovili na 5 minút. Ak za tento èas aplikácia nehlásila prítomnos techniky \textit{process hollowing}, vısledok detekcie sme oznaèili za negatívny a proces ukonèili. Kadá vzorka, ktorá sa dostala postupne do posledného stavu v koneènom automate bola oznaèená ako správne detegovaná.

\subsection{Vyhodnotenie}

Z nami vybranıch vzoriek aplikácia správne detegovala tri vzorky. Zvyšné vzorky však neboli detegované. Ako môeme vidie v tabu¾ke è.\ref{vzorky}, èas detekcie v prípade spomínanıch troch vzoriek bol krátky. Otázkou však ostávajú zvyšné vzorky, ktoré sa nám nepodarilo detegova. Príèin môe by viacero. Prvım dôvodom môe by, e vzorka pouívala urèitú variáciu techniky \textit{process hollowing}, s ktorou náš koneènı automat nepoèítal. Otázne môu by aj informácie uvedené v blogoch a skutoènos èi dané vzorky skutoène obsahovali injektovanie pomocou \textit{process hollowing}. 

Jednou z príèin môe by taktie fakt, e niektoré vzorky nemusia vykonáva \textit{process hollowing} priamo. To znamená e daná vzorka môe napr. uklada spustite¾nı súbor na disk a ten následne spúša. Injektovanie môe by následne a v tom druhom procese, v ktorom u nemáme vloenı náš DLL súbor a teda nedokáeme sledova API volania. Niektoré vzorky taktie zvyknú sahova škodlivé súbory z URL adresy. Detailnejšou analızou sme sa však v práci nezaoberali.

